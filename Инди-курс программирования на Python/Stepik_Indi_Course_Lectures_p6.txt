

============= 6.1 Значение None ============

https://stepik.org/lesson/761084/step/1?unit=763185


Во многих языках программирования и в языке SQL есть специальное значение, обозначающее нейтральное пустое значение.

Вот и python не стал исключением, в нем присутствует аналогичное значение, которое называется None


"   Введение в значение None   "

В python значение None — это специальный объект, принадлежащий типу данных NoneType. Он обозначает отсутствие значения


print(None)
print(type(None))			# <class 'NoneType'>


"None — это одноэлементный объект(синглтон) класса NoneType. Синглтон означает, что может быть только один его экземпляр."

"Фактически, все переменные, которым присвоено значение None, указывают на один и тот же объект в Python."


a = [1,2,3]
b = [1,2,3]

print(id(a), id(b))

print(a == b, a is b) 
			
print('-'*15)

c = None
d = None

print(id(c), id(d))  					# 4461917840    4461917840

print(c == d, c is d)



"При помощи функции id() мы можем определить адрес в памяти, где хранится объект."

Видите, что мы можем создать два списка с одинаковым значением [1,2,3], и они будут храниться в разных адресах памяти(у них разные id). 

"Но переменные, хранящие в себе значение None , ссылаются на один и тот же адрес в памяти."



========== Операции со значением None ===========


" Значение None не поддерживает никакие математические операции. "

При попытке выполнить сложение, умножение и т.д вы сразу же получите ошибку TypeError: unsupported operand type(s)


None + 4

None - [ ]

None * None

"  None может участвовать только в операции сравнения, а именно проверки на равенство/неравенство  "


========== Сравнение со значением None ===========

Сравним сперва None с собой же.  Тут есть два варианта:

" 1. знакомый вам оператор сравнения ==, он сравнивает по значению "

" 2. оператор is, который сравнивает по адресам в памяти (значит сравнение идет по id) "


print(None == None)
print(None is None)

print('-'*5)

print(None != None)
print(None is not None)

print('-'*5)

print(None in [1, 2, 3])
print(None in [1, None, 3])


"  Но good practice для сравнения с None это использовать операторы is и is not. "


"  Если попытаетесь сравнить значение None с любым другим значением, отличным от None, всегда получите False. "


print(None == 1)

print(None == 'Hello')

print(None == '')

print(None == 0)

print(None == [])


"  ===== Важно отметить, что объект None имеет следующие особенности  =====  "

None не равно нулю 0 или 0.0

None не то же самое, что False

None — это не пустая строка ('')

None - это не пустой список и не любое другое значение


=> "  None не равен никому кроме себя. "


"  И сравнить None можно только равенство или неравенство с другим объектом.  "

"  При попытке использовать сравнение на больше/меньше вы получите ошибку  "


print(None > 5)
print(None < None)



===== Где используется None =====


1) Для инициализации переменной. 

" Когда вам нужно создать переменную, но вы еще не определили значение для нее, вы можете присвоить ей None  "


person = None

print(person)

if person is None:
  print("Person is not defined")
else:
  print(f"Person={person}")


===============================

Какой результат будет у сравнения ниже?

None == None 					=> True

***

Какой результат будет у сравнения ниже?

None <= None						=> False
	
***
Какой результат будет у сравнения ниже?

None is None						=> True

***
 Что считается лучшей практикой, когда нужно проверить на значение None:  оператор == или оператор is? 
" => is "

***

Какой результат будет у сравнения ниже?

None != None 			=> False


***

Какой результат будет у сравнения ниже?

None is not None 		=> False


***

Какой результат будет у сравнения ниже?

None not is None 			=> Error


***

Какой результат будет у операции ниже?

None in ['hello', 'None', 'none', 234] 		=> False

***

Какой результат будет у операции ниже?

None in ['hello', None, 'none', 234]


***
Cоздайте две переменные empty и empty_too, сохраните в них значение None

При помощи оператора is выведите на первой строке результат их сравнения на равенство и затем на второй строке результат их сравнения на неравенсто


empty = None
empty_too = None

print(empty is empty_too)
print(empty is not empty_too)


~~

print((empty := None) is (empty_too := None))
print(empty is not empty_too)

~~

print((empty:=None) is (empty_too:=None), empty is not empty_too, sep='\n')


***

Создайте список i_love_none из 50 элементов None и распечатайте его


# create a list of 50 None items

i_love_none = [None] * 50

print(i_love_none )

***

i_love_none = []

for i in range(50):
    i_love_none.append(None)
    
print(i_love_none)


***

print(i_love_none := [None] * 50)

***

i_love_none = [None for i in range(50)]
print(i_love_none )

***

a = [None]
i_love_none = a * 50
print(i_love_none)



============== 6.2 Кортежи (tuple). Операции и методы кортежей ===============



Вид данных кортеж (tuple)


"Кортеж (tuple) – неизменяемая упорядоченная последовательность, обычно используемая для хранения разнотипных объектов. "  

" Кортеж очень напоминает список, но только кортеж является неизменяемым типом данных."


			"	*** Варианты создания кортежа.  "
				
1) С помощью перечисления элементов в круглых скобках:

a = (1, 2, 3, 4, 5)
print(a, type(a))

b = ('hello', 45, True)
print(type(b))
print(b)


2) Пропустить круглые скобки и записать объекты через запятую:

a = 1, 2, 3, 4, 5
print(a, type(a))

b = 'hello', 45, True
print(type(b))
print(b)



"  Это работает с любым количеством элементов, только если вам нужно создать кортеж из одного элемента, нужно обязательно не забыть указать запятую после этого элемента:  "

a = 1,
print(type(a)) 		<class 'tuple'>


b = 1
print(type(b)) 		<class 'int'>


3) При помощи функции tuple(). Ей надо передать итерируемый объект: например range(), список или строку


a = tuple(range(5))
print(a, type(a))

b = tuple('hello')
print(b, type(b))


my_list = [43, True, 'The Boys']
c = tuple(my_list)
print(c, type(b))


" ======== Создание пустого кортежа ======= "

Пустой кортеж можно создать следующими способами:

a = ()
print(a, type(a))

b = tuple()
print(b, type(b))



"========== Операции с кортежами ============"

Нахождение длины кортежа

При помощи функции len() можем найти количество элементов кортежа

a = 1, 2, 3, 4, 5
print(len(a))

b = 'hello', 45, True
print(len(b))

empty = ()
print(len(empty))




"========== Проверка на нахождение ============"


"Оператор in – позволяет проверить имеется ли элемент в кортеже. Если данный элемент присутствует, то результат будет  True, в обратном случае – False."

a = 1, 2, 3, 4, 5

print(2 in a) 
print(7 in a)
print(6 not in a)



"========== Сложение кортежей ============"

Сложение (сцепление) кортежей. Порядок сложения имеет значение

a = 1, 2, 3, 4, 5
b = (6, 7, 8)

c = a + b
d = b + a
print(c)
print(d)


"Кортеж с другими типами данных не поддерживает операцию сложения"


"========== Дублирование кортежей ============"

Чтобы продублировать кортеж необходимо его умножить на целое число:

a = 1, 2, 3, 4, 5

print(a*2)

print((6, 7, 8)*4)



"========== Поиск максимума и минимума ============"

Функции min(), max() позволяют узнать минимальный и максимальный элемент кортежа


a = 1, 2, 3, 4, 5

print(min(a), max(a))


Функции min(), max() можно использовать только если кортеж состоит из однотипных элементов, которые можно сравнить между собой (целиком из чисел или целиком из строк). Если бы наш кортеж был бы таким:

a = (1, 2, 'hi', 4, 5)

то получили бы ошибку.



"========== Суммирование элементов кортежа ============"


Просуммировать элементы кортежа (если он состоит исключительно из чисел):

a = 1, 2, 3, 4, 5

print(sum(a))

b = tuple(range(200, 301))
print(sum(b))


Функция sum() можно использовать только если кортеж состоит целиком из числовых элементов. Если бы наш кортеж был бы таким:

a = (1, 2, 'hi', 4, 5)
то получили бы ошибку.




================= 6.3 Кортежи ============================

https://stepik.org/lesson/767366/step/1?unit=769760


Кортежи, как и списки, являются упорядоченной коллекцией, то есть все элементы пронумерованы и имеют свой порядковый номер - индекс. Поэтому мы также можем обращаться к элементам по индексам



"========== Индексация кортежей ============"

a = (1, 'hi', 3, 54, False, 6)
print(a[1])
print(a[4])
print(a[0])

print(a[-1])
print(a[-5])



"========== Срезы индексов у кортежей ============"

a = (1, 'hi', 3, 54, False, 6, 'the', True)

print(a[1:4])
print(a[5:])
print(a[:3])

print(a[:])
print(a[::-1])



"========== Неизменяемость кортежей ============"


При попытке изменить значение у кортежа по его индексу возникнет ошибка

TypeError: 'tuple' object does not support item assignment


a = (1, 'hi', 3, 54, False, 6, 'the', True)
a[1] = 100

print(a) 					=> TypeError:


" Уже созданные кортежи изменять нельзя, но вы можете создавать на их основании новые кортежи "


" Но если внутри кортежа имеется изменяемый объект (к примеру список), то на элементы изменяемого объекта можно влиять "

a = (1, 2, [10, 20], 3)
a[2].append(30)
print(a)

a[2][0] = 'hello'
print(a)



"========== Как вносить изменения в кортеж ============"

Но если вдруг нужно изменить значение в кортеже то как же это можно провернуть. И тут у вас есть два варианта:

" 1. использование срезов и сцеплений (неприятный вариант) "


a = (1, 'hi', 3, 54, False, 6, 'the', True)
print(a)

# хотим изменить индекс 2 на значение 100 

# и в конец добавить значение 999

a = a[:2] + (100, ) + a[3:] + (999, )

print(a)



" 2. преобразовать к списку ➔ изменение элемента ➔ преобразование в кортеж (приятный вариант):  "


a = (1, 'hi', 3, 54, False, 6, 'the', True)
print(a)

# хотим изменить индекс 2 на значение 100 
# и в конец добавить значение 999

a = list(a)

a[2] = 100

a.append(999)

a = tuple(a)

print(a)



*****************

Кортеж является  => неизменяемым объектом

Кортеж является =>  упорядоченной коллекцией

Кортеж является  => итерируемым объектом


***

 Что увидим на экране после этого кода?

my_tuple = (10, 20, 30, 40, 50)
my_tuple[1] = 60
print(my_tuple) 				=> TypeError





"========== Обход элементов кортежа ============"


Поскольку кортеж является последовательностью, то значит мы можем итерироваться по ней, или, другими словами, обходить его элементы при помощи цикла for:


a = (1, 'hi', 3, 54, False, 6, 'the', True)
for item in a:
    print(item)
    

" Но поскольку кортеж это упорядоченная коллекция, то элементы можно обходить не только по значениям, но и по индексам: "


a = (1, 'hi', 3, 54, False, 6, 'the', True)

for item in range(len(a)):

    print(f'Индекс={item}, значение={a[item]}')



"========== Когда стоит использовать кортежи? ============"


Вот несколько случаев, когда применение кортежей лучше, чем списки:


1. Вам необходимо гарантировать неизменяемость объектов (в списках есть вероятность того, что в процессе программы значения списка могут потеряться или измениться).


# Изменяемость списков через разделяемые ссылки
a = [1, 2, 3]
b = a
b[1] = 100
print(b, a)

"Произошли изменения в обоих списках, поскольку они ссылались на один и тот же объект. В кортеже такого произойти не смогло бы. Поэтому для хранения констант в вашей программе кортежи идеально подойдут"



2.  Кортеж занимает меньше места в памяти и скорость их обработки выше, поэтому при работе с большим объемом данных, лучше использовать кортеж. 

Возьмём абсолютно одинаковую последовательность данных, и занесём её в кортеж и в список, и при помощи метода __sizeof__() узнаем сколько памяти они занимают в байтах:



a = (1, 'hi', 3, 54, False, 6)
b = [1, 'hi', 3, 54, False, 6]

print(a.__sizeof__())			# 72
print(b.__sizeof__())			# 88

Как мы видим, с такой разницей в занимаемой памяти, при большом количестве объектов в коллекции кортежи являются более выгодными.



3. В отличии от списков кортежи могут быть ключами словаря



"========== Методы кортежей ============"

" Kортежи являются неизменяемыми объектами, записываются в круглых скобках и очень похожи на списки. "

Если вспомнить списки, то у них было много методов, меняющих само состояние списка и его элементов (append, sort, reverse, remove и т.д.). 

" А кортежи из-за своей неизменяемости не могут обладать подобными методами и отсюда мы получаем очень незначительную функциональность: только два метода index и count "


************  " Метод index " *****************

Метод index() - показывает первый слева индекс элемента, если он присутствует в кортеже:

a = (1, 2, 3, 54, 8, 6, 2, 7)
print(a.index(54))
print(a.index(3))
print(a.index(2))


" При попытке узнать индекс элемента, который не входит в кортеж, происходит ошибка ValueError. "


************  " Метод count " *****************


Метод count() выполняет подсчёт количества вхождений данного элемента в кортеж

a = (1, 2, 3, 54, 8, 6, 2, 7)

print(a.count(54))
print(a.count(99))
print(a.count(2))


==========================

Сохраните в переменной my_tuple кортеж состоящий из 4 любых элементов.



my_tuple = (1,2,3,4)

~~

my_tuple = ('Спасибо', 'автору', 'за', 'курс!!!')

~~

my_tuple = (1, ) * 4

~~

my_tuple = tuple(range(4))

~~

from random import randint

my_tuple = tuple([randint(1, 100) for _ in range(4)])

~~

my_tuple = ()

for i in range(4):
    my_tuple += (i,)

~~

my_tuple = (1, '2', [3], (4))


*************************************

Как можно создать пустой кортеж и сохранить в переменной b?

b = ()

b = tuple()

*****

Сохраните в переменной lonely кортеж из одного элемента: 777

Распечатайте на экран lonely


lonely = (777,)
print(lonely)

~~

print(lonely := 777,)

~~

lonely=tuple([777])
print(lonely)

~~

lonely = 777,

print(lonely)

***********************

Что увидим на экране после этого кода?

my_tuple = (1120, -432, 1234, 4987, -87390)
print(max(my_tuple))


*************************

Что увидим на экране после этого кода?

my_tuple = (1120, 'a', 1234)

print(max(my_tuple)) 			=> TypeError


************************

Что увидим на экране после этого кода?

my_tuple = ('zara', 'h&m', 'mcdonalds', 'visa', 'ikea')

print(min(my_tuple)) 			=> h&m



**************************

my_tuple = ('zara', 'h&m', 'mcdonalds', 5, 'ikea')

print(min(my_tuple))					=> TypeError


*************************

Допишите программу ниже, чтобы она вывела через пробел в одной строке значения самого маленького и самого большого элементов кортежа my_tuple.

my_tuple = (-214, 181, -139, 448, -664, -66, 213, 832, 717, -462, -924, -706, -85, -244, -222, -340, -482, -518, -781, 759, -593, 905, -354, -377, -141, -742, 383, -381, 109, -639, -480, -810, -686, 892, -612, 696, 993, 791, 631, -493, -218, -829, -275, 619, -628, -241, -565, -835, -69, 747, 711, -252, -811, -407, -153, 904, 933, -254, 307, -493, -419, -109, -543, 155, -127, 613, -452, -459, 856, 562, 333, -66, -77, -598, -779, -278, 867, 321, -20, -415, -357, 735, -906, -14, -370, 453, -630, -736, -830, -917, 32, 422, -895, 198, 284, 472, -986, -964, -73, 29)

print(f'{min(my_tuple)} {max(my_tuple)}')


print(min(my_tuple), max(my_tuple))



print(min(my_tuple), max(my_tuple), end=' ')

~~

class TupleValues:
    def __init__(self, my_t):
        self.min_value = min(my_t)
        self.max_value = max(my_t)

    def get_min_and_max(self):
        return self.min_value, self.max_value


t = TupleValues(my_tuple)

print(*t.get_min_and_max())


~~

i_max = 0
i_min = 0

for i in my_tuple:
    if i > i_max:
        i_max = i

for i in my_tuple:
    if i < i_min:
        i_min = i
print(i_min, i_max)



**********************************

Допишите программу ниже, чтобы она вывела среднее арифметическое всех элементов кортежа my_tuple.



avg = sum(my_tuple) / len(my_tuple)

print(avg)


~~

m = list(i for i in my_tuple if i % 2)
print(sum(m) / len(m))



m = tuple(i for i in m if i%2!=0)
print(sum(m) / len(m))

~~

print(sum(my_tuple) / len(my_tuple))

~~

a = 0
count = 0
for i in my_tuple:
    if i % 2 != 0:
        a += i
        count += 1
        
print(a / count)

~~

print((lambda x: sum(x) / len(x))([num for num in my_tuple if abs(num) % 2 != 0]))

~~

z = [i for i in my_tuple if i % 2]
print(sum(z) / len(z))


a = [i for i in my_tuple if i%2==1]
print(sum(a)/len(a))


~~

print(sum([i for i in my_tuple if i % 2 == 1]) / len([i for i in my_tuple if i % 2 == 1]))


**********************************

Какой тип данных увидим на экране, если распечатать код ниже?

my_tuple = ("Orange")
print(type(my_tuple)) 					=> str


********************************

Что увидим на экране после этого кода?

my_tuple = (100,)
print(my_tuple * 3) 			=> (100, 100, 100)



**********************************

При помощи операций сцепления и дублирования сохраните в переменной result следующий кортеж 

Он состоит из:

трех единиц
пяти букв R
восьми букв A
пяти цифр 2

Для удобства можете пользоваться переменными a b c d

В качестве ответа выведите содержимое переменной result


# умножением дублируем кортеж необхожимое количество раз и потом их складываем
print(a * 3 + b * 5 + c * 8 + d * 5) 


~~

a = (1,) * 3
b = ('R',) * 5
c = ('A',) * 8
d = (2,) * 5

print(a + b + c + d)


~~

print(result := (1,)*3 + ('R',)*5 + ('A',)*8 + (2,)*5)

~~

cell = ((3, 1), (5, 'R'), (8, 'A'), (5, 2))

res = ()
for x in cell:
    temp = ()
    for a in range(x[0]):
        temp += x[1],
    res += temp
    
print(res)

~~

a = (1,)
b = ('R',)
c = ('A',)
d = (2,)
result= tuple(a*3+5*b+c*8+d*5)
print(result)


**********************************

Вывести кортеж, содержащий натуральные числа в интервале [a; b]


a, b = int(input()), int(input()) 

c = tuple(range(a, b+1)) 

print(c)


~~

a, b = int(input()), int(input())

print((*range(a, b + 1),))


~~

a = int(input())
b = int(input())
c = []

for i in range(a,b + 1):
    c.append(i)
c = tuple(c)

print(c)


~~~

print(tuple([i for i in range(int(input()), int(input())+1)]))

~~~

a, b = int(input()), int(input())

print(tuple(i for i in range(a, b + 1)))


*******************************************

Сформировать кортеж, содержащий нечетные натуральные числа в интервале [ n; n^2 ] и вывести его на экран.


n = int(input())  # получаем число для отчета последовательности
c = []  # создаем пустой список для добавления подходящих чисел

for i in range(n, n ** 2 + 1):  # циклом мы создаем последовательность чисел от n до n**2(включительно)
    if i % 2 != 0:  # выбераем только нечетные числа
        c.append(i)  # добавляем в список подходящие числа
print(tuple(c))  # преобразовываем список в кортеж и выводим его


~~

x = int(input())

print(tuple([n for n in range(x, x * x + 1) if n % 2 == 1]))

~~

n=int(input())

print(tuple(i for i in range(n, n ** 2 + 1) if i%2 != 0 ))

~~

n = int(input())
print(tuple(range(n | 1, n ** 2 + 1, 2)))

~~

[print(tuple(_ for _ in range(n, n * n + 1) if _ % 2)) for n in [int(input())]]

~~

print(tuple([i for i in range(n, n ** 2 + 1) if i % 2]) if (n := int(input())) else None)

~~

n = int(input())
print(tuple(range(n // 2 * 2 + 1, n ** 2 + 1, 2)))

~~

************************************

Перед вами кортеж my_tuple 

Выведите сперва на отдельной строке элемент, хранящийся под индексом 44, а затем на следующей строке - девятое с конца значение

my_tuple = (32, 45, 32, 60, 43, 19, 39, 75, 50, 12, 53, 13, 28, 70, 68, 5, 64, 55, 30, 47, 23, 20, 17, 36, 45, 31, 46, 50, 33, 45, 9, 41, 12, 57, 40, 43, 47, 51, 56, 54, 40, 30, 37, 23, 43, 66, 64, 27, 44, 75, 51, 2, 19, 72, 30, 8, 29, 43, 7, 73, 34, 65, 54, 50, 43, 6, 50, 45, 49, 30, 39, 50, 41, 70, 38, 16, 31, 51, 72, 45, 58, 39, 50, 56, 24, 30, 9, 53, 27, 31, 68, 56, 26, 39, 34, 50, 10, 12, 3, 27)

idx44 = my_tuple[44]
idx9 = my_tuple[-9]
print(idx44)
print(idx9)


~~

[print(my_tuple[i]) for i in (44, -9)]

~~

print(my_tuple[44],my_tuple[-9],sep="\n")

~~

a = [44,-9]
for i in a:
    print(my_tuple[i])
    
~~

[print(my_tuple[key]) for key in (44, -9)]

~~

print(my_tuple[44], my_tuple[-9], sep='\n')

~~

print(my_tuple[44], my_tuple[-9], sep='\n')


*********************************

Перед вами кортеж my_tuple 

При помощи среза сохраните

в переменную slice_5_10 значения с 5-го индекса по 10-й включительно
в переменную slice_from_20 значения с 20-го индекса и по конец кортежа
в переменную slice_to_35 значения с начала кортежа по 35-й индекс не включительно
Распечатайте данные переменные на отдельных строках в порядке их перечисления


slice_5_10 = my_tuple[5:11]
slice_from_20 = my_tuple[20:]
slice_to_35 = my_tuple[:35]

print(slice_5_10)
print(slice_from_20)
print(slice_to_35)

~~

t = (32, 45, 32, 60, 43, 19, 39, 75, 50, 12, 53, 13, 28, 70, 68, 5, 64, 55, 30, 47, 23, 20, 17, 36, 45, 31, 46, 50, 33, 45, 9, 41, 12, 57, 40, 43, 47, 51, 56, 54, 40, 30, 37, 23, 43, 66, 64, 27, 44, 75, 51, 2, 19, 72, 30, 8, 29, 43, 7, 73, 34, 65, 54, 50, 43, 6, 50, 45, 49, 30, 39, 50, 41, 70, 38, 16, 31, 51, 72, 45, 58, 39, 50, 56, 24, 30, 9, 53, 27, 31, 68, 56, 26, 39, 34, 50, 10, 12, 3, 27)
print(t[5:11], t[20:], t[:35], sep='\n')


*************************************

При помощи среза разверните/переверните кортеж my_tuple и распечатайте на экран полученное значение

Развернуть(reverse) кортеж или любую другую упорядоченную коллекцию это значит расположить элементы в обратном порядке от последнего до первого

print(my_tuple[::-1])


~~

my_list = list(my_tuple)
my_list.reverse()

my_tuple = tuple(my_list)
print(my_tuple)


~~

print(tuple(reversed(my_tuple)))

~~


***************************************

Нужно посчитать и вывести на экран сколько раз встречается значение 50 в кортеже my_tuple


print(my_tuple.count(50))


~~

print(sum(map(lambda x: x == 50, my_tuple)))

~~

"   print(sum((el == 50 for el in my_tuple)))   "

~~

count = 0

for i in my_tuple:
    if i == 50:
        count += 1
        
print(count)


~~

from collections import Counter

my_tuple = (32, 45, 32, 60, 43, 19, 39, 75, 50, 12, 53, 13, 28, 70, 68, 5, 64, 55, 30, 47, 23, 20, 17, 36, 45, 31, 46, 50, 33, 45, 9, 41, 12, 57, 40, 43, 47, 51, 56, 54, 40, 30, 37, 23, 43, 66, 64, 27, 44, 75, 51, 2, 19, 72, 30, 8, 29, 43, 7, 73, 34, 65, 54, 50, 43, 6, 50, 45, 49, 30, 39, 50, 41, 70, 38, 16, 31, 51, 72, 45, 58, 39, 50, 56, 24, 30, 9, 53, 27, 31, 68, 56, 26, 39, 34, 50, 10, 12, 3, 27)

print(Counter(my_tuple)[50])


**********************************

Перед вами кортеж words_tuple 

При помощи цикла for обойдите слова, хранящиеся в кортеже words_tuple, и для каждого элемента выведите строку вида

Длина слова {word} = {len_word}
Например, для кортежа words_tuple=('hi', 'world') ответ был бы таким:

Длина слова hi = 2
Длина слова world = 5


words_tuple = ('quaint', 'leftovers', 'thesis', 'density', 'retired', 'weak', 'tolerate',
               'sensitivity', 'primary', 'definition', 'determine', 'bring', 'monstrous',
               'hurl', 'timetable', 'month', 'advocate', 'provoke', 'stress', 'omission')

for i in words_tuple:                    
    print(f'Длина слова {i} = {len(i)}') 


~~

[print(f'Длина слова {word} = {len(word)}') for word in words_tuple]

~~

print(*[f"Длина слова {i} = {len(i)}" for i in words_tuple],sep='\n')

~~

print(*(f'Длина слова {s} = {len(s)}' for s in words_tuple), sep='\n')


*********************************

Допишите программу ниже, чтобы она вывела среднее арифметическое всех нечетных значений, хранящихся в кортеже my_tuple.

my_tuple = (-214, 181, -139, 448, -664, -66, 213, 832, 717, -462, -924, -706, -85, -244, -222, -340, -482, -518, -781, 759, -593, 905, -354, -377, -141, -742, 383, -381, 109, -639, -480, -810, -686, 892, -612, 696, 993, 791, 631, -493, -218, -829, -275, 619, -628, -241, -565, -835, -69, 747, 711, -252, -811, -407, -153, 904, 933, -254, 307, -493, -419, -109, -543, 155, -127, 613, -452, -459, 856, 562, 333, -66, -77, -598, -779, -278, 867, 321, -20, -415, -357, 735, -906, -14, -370, 453, -630, -736, -830, -917, 32, 422, -895, 198, 284, 472, -986, -964, -73, 29)


count = 0
new_lst = []


for i in my_tuple:
    if i % 2 != 0:
        new_lst.append(i)
        count += 1


avg = sum(new_lst) / count

print(avg)


~~

t = [i for i in my_tuple if i %2 != 0]
print(sum(t) / len(t))

~~

print(sum(a := [i for i in my_tuple if i % 2 == 1 ]) / len(a))


~~

res = list(filter(lambda x: x % 2, my_tuple))
print(sum(res) / len(res))

~~

sum,count=0,0

for i in range(len(my_tuple)):
    if (my_tuple[i]) % 2 != 0:
        sum+=my_tuple[i]
        count+=1
        
print(sum/count)


~~

print(sum(i for i in my_tuple if i % 2 != 0) / sum(1 for i in my_tuple if i % 2 != 0))


~~

print(sum(x := [i for i in (-214, 181, -139, 448, -664, -66, 213, 832, 717, -462, -924, -706, -85, -244, -222, -340, -482, -518, -781, 759, -593, 905, -354, -377, -141, -742, 383, -381, 109, -639, -480, -810, -686, 892, -612, 696, 993, 791, 631, -493, -218, -829, -275, 619, -628, -241, -565, -835, -69, 747, 711, -252, -811, -407, -153, 904, 933, -254, 307, -493, -419, -109, -543, 155, -127, 613, -452, -459, 856, 562, 333, -66, -77, -598, -779, -278, 867, 321, -20, -415, -357, 735, -906, -14, -370, 453, -630, -736, -830, -917, 32, 422, -895, 198, 284, 472, -986, -964, -73, 29) if i % 2 == 1]) / len(x))

~~

print(sum(tpl := tuple(_ for _ in my_tuple if _ % 2)) / len(tpl))

~~

a = [i for i in my_tuple if i % 2]
print(sum(a) / len(a))



================  6.4 Словарь. Знакомство с типом данных dict  ================

https://stepik.org/lesson/761760/step/1?unit=763882


Словарь (его еще называют ассоциативным списком) – неупорядоченная совокупность произвольных объектов с доступом по ключу.

У списков все элементы имеют свой порядковый номер(индекс) и каждый элемент связан с этим порядковым номером. В этом прелесть списков, но и недостаток. Минус в том, что вы не можете сделать другую связь, всегда связь значения списка с числом, которое представляет индекс.

Словари позволяют сделать связь между значением и другим объектом, не только с числом.


Давайте рассмотрим пример, возьмем список с городами:

a = ['moscow', 'saint petersburg', 'penza']


По умолчанию элемент moscow ассоциируется с индексом 0, saint petersburg - с индексом 1, а penza - с индексом 2. Но что, если нам нужно, чтобы наши города ассоциировались с другими числами, например с телефонным кодом города?


У города moscow телефонный код - 495, у saint petersburg - 812, у penza – 8412. Подобные соответствия можно назвать ассоциацией и для создания таких ассоциацией в python существует объект под названием словарь(dictionary). Немного сократив английское слово dictionary, получаем название типа данных dict.



=============== Способы создания словаря ==============


					" 1 вариант "

Для создания словаря необходимо открыть фигурные скобки {} и поочередно через запятую указывать пары элементов, разделенных двоеточием. 

Первый элемент пары называется ключ, а второй – значение. 

"Каждая такая пара является одним элементом словаря."

cities = {
   "moscow": 495, 
   "saint petersburg": 812, 
   "penza": 8412
}


print(cities)
print(type(cities))



			" 2 вариант "


Словарь можно создать при помощи функции dict(). 

Внутри функции dict() пишем ключ и присваиваем ему значение:



cities = dict(moskva=495, piter=812, penza=8412)

print(cities)
print(type(cities))


** " Обратите внимание на то, что внутри функции dict() значение ключей мы пишем без кавычек, поскольку эта функция автоматически приведёт ключи к строке."


** " Но такой способ создания словарей используется только тогда, когда в качестве ключа выступает строковой тип данных. Использование чисел или иных типов данных приведёт к ошибке. "


2.2)  Создаем отдельный вложенный список, элементами которого будут списки, состоящие из двух элементов: первое будет ключом, второе – значением.

a = [['moskva',495], ['piter', 812], ['penza', 8412]]
cities = dict(a)

print(cities)
print(type(cities))




			===== Способы создания пустого словаря =====


" 1) Пустой словарь можно создать при помощи пустых фигурных скобок {}  "


empty_dict = {}

print(empty_dict)
print(type(empty_dict))


" 2) Пустой словарь можно создать при помощи функции dict() с пустыми параметрами:  "


another_empty_dict = dict()

print(another_empty_dict)
print(type(another_empty_dict))


************************

Как создать пустой словарь и сохранить его в переменной d?

d = {}

d = dict()



Создайте пустой словарь и сохраните его в переменную my_dict, затем выведите на экран эту переменную

my_dict = {}

~~

my_dict = dict()

print(my_dict)

~~

print(my_dict:= dict())

~~

print(my_dict := {})



**************************


Какой тип данных мы увидим если у переменной d вызвать функцию type()?

d = {}

print(type(d)) 			=> <class 'dict'>


**************************

Создайте словарь, у которого должны быть следующие пары ключ-значения

person = {
    'name': 'Vasya',
    'surname': 'Petrov',
    'age': 25
}

print(person)


~~

person = dict(name='Vasya', surname='Petrov',  age=25)
print(person)

~~

s = """name - строка	Vasya - строка
surname - строка	Petrov - строка
age - строка	25 - целое число"""

person = {}

for line in s.splitlines():

    k, v = map(lambda s: s.split(' ')[0], line.split('	'))
    person[k] = int(v) if k == 'age' else v
    
print(person)


~~

person = [['name','Vasya'], ['surname','Petrov'], ['age',25]]

print(person := dict(person))

~~

person = dict((('name', 'Vasya'), ('surname', 'Petrov'), ('age', 25)))
print(person)

~~

a, b = ['name', 'surname', 'age'], ['Vasya', 'Petrov', 25]
person = dict(zip(a, b))
print(person)

~~

person = dict(zip(('name', 'surname', 'age'), ('Vasya', 'Petrov', 25)))
print(person)

~~

person={}
person['name']='Vasya'
person['surname']='Petrov'
person['age']=25

print(person)


~~


============  Работаем с ключами и значениями словаря  ============

https://stepik.org/lesson/761760/step/6?unit=763882


" Каждый элемент словаря состоит из пары ключ : значение. "



*********** " Обращение по ключу "

Словари как и списки поддерживают операцию индексации, только вместо индекса нужно указывать значения ключа. 

У словарей вообще нету понятия индекса, потому что словари - это неупорядоченная коллекция данных. 

Поэтому обращаться можно только по ключу через квадратные скобки


d = {1: 'one', 2: 'two', 3: 'three'}

print(d[2])
print(d[3])

lang = {'eng':'Английский', 'ru':'Русский'}

print(lang['ru'])
print(lang['eng'])



" При обращении к ключу, которого в списке нет, мы получим ошибку KeyError. "

lang = {'eng':'Английский', 'ru':'Русский'}

print(lang['ru'])
print(lang['eng'])
print(lang['Русский'])


Из примера выше мы видим, что у нас есть два ключа eng и ru, среди них нет значения Русский. Отсюда мы делаем следующий вывод:

" связь в паре ключ:значение односторонняя: мы можем по ключу получить значение, а по значению ключ мы не получим "


========= " Создание новой пары ключ:значение "  ==========

Для того, чтобы добавить новое значение в словарь необходимо обратится по новому ключу и присвоить туда значение вот в таком формате:

" словарь[новый ключ] = значение "


" Таким образом, наш словарь пополнится новой парой ключ:значение "

lang = {'eng':'Английский', 'ru':'Русский'}
print(lang)

lang['fra'] = 'Французский'
print(lang)

lang['esp'] = 'Испанский'
print(lang)

print(lang['fra'], lang['esp'])



========= "Изменение существующей пары ключ:значение "  ==========


" Если присвоить новое значение уже существующему ключу, то мы просто заменим старое значение.  "

lang = {'eng':'Английский', 'ru':'Русский'}
print(lang)

lang['ru'] = 'Russian'
print(lang)

lang['esp'] = 'Испанский'
print(lang)

name = 'esp'

lang[name] = 'Español'

print(lang)


" Значит в словаре не может быть двух пар с одинаковыми ключами "


И раз мы смогли изменить существующий элемент словаря, значит можно сделать вывод что словарь является изменяемым объектом



========= " Удаление существующей пары ключ:значение "  ==========

" Для того, чтобы удалить значение из словаря необходимо воспользоваться функцией del и обратится по ключу у словаря "

d = {1: 'one', 2: 'two', 3: 'three'}
print(d)

del d[2]
print(d)

del d[3]
print(d)


" При попытке удалить ключ, которого нет в словаре,  возникнет ошибка KeyError.  "


lang = {'eng':'Английский', 'ru':'Русский'}
print(lang)
del lang['esp']



========= " Требования к ключу словаря "  ==========



Есть важная особенность при работе с ключами словаря, которую нужно запомнить, а именно

" Ключом может быть только неизменяемый объект "


							*** " К неизменяемым объектам относятся  " ***
		

		1. целые(тип int) и вещественные(тип float) числа
		2. строки (тип str)
		3. None
		4. кортежи (тип tuple) 
		5. неизменяемые множества (тип frozenset) 



							*** "  K изменяемым объектам относятся  " ***
		
		1. списки (тип list)
		2. множества (тип set) 
		3. сами словари (тип dict)

"  Из этого следует, что ключом словаря не может быть список, множество или словарь.  "


"  Если попытаетесь использовать изменяемый тип в качестве ключа, получите ошибку TypeError: unhashable type "


d = {}
my_list = [1, 2, 3]

d[my_list] = 'hello'


************ Требования к значению словаря ***************

можете выбрать любой тип данных в качестве значения словаря

d = {}
d[1] = 'Соточка'
d[3.14] = 'Pi'
d['pi'] = 3.14
d['values'] = [1, 2, 3]
d['dictionary'] = dict(a=10, b=20)

print(d)
print(d['dictionary'])
print(d['values'])


" Для красивого вывода словаря можно использовать функцию pprint из модуля pprint "

from pprint import pprint

pprint обозначает pretty print


from pprint import pprint  # для красивого вывода словаря

person = {}
s = 'IVANOV IVAN 19 Samara SGU 4 5 5 5 4 3 5 3'

s = s.split()
print(s)
print('-' * 15)
person['last_name'] = s[0]
person['first_name'] = s[1]
person['age'] = int(s[2])
person['city'] = s[3]
person['university'] = s[4]

print(person)
print('-' * 15)

person['marks'] = []
for i in s[5:]:
    person['marks'].append(int(i))

pprint(person) 		=> 
Увидим на экране 30


********************************

sweet = {
    "id": "0001",
    "type": "donut",
    "name": "Cake",
    "ppu": 0.55,
    "calories": 125,
}

print(sweet['name'])
print(sweet['calories'])
print(sweet['id'])


~~

for key in ('name', 'calories', 'id'):
    print(sweet[key])

~~

print(sweet.get('name'), sweet.setdefault('calories'), sweet['id'], sep='\n')


~~

[print(sweet[key]) for key in ('name','calories','id')]


~~

[print(sweet[k]) for k in 'name calories id'.split()]


~~

print(sweet['name'], sweet['calories'], sweet['id'], sep='\n')

~~


******************************

Что произойдет после запуска следующей программы?

man = {"name": "John", "age": 30, "car": None}
print(man[30]) 		=> Получим ошибку KeyError



******************************

В вашем распоряжении имеется словарь days, в котором в качестве ключей хранится номера месяца, а в качестве значения - количество дней в соответствующем месяце (будем исключать високосные года и полагать, что в феврале всегда 28 дней)

Ваша программа получает на вход номер месяца, гарантируется что это будет число в пределах от 1 до 12.

Ваша задача по введеному номеру месяца вывести количество дней


days = {
    1: 31,
    2: 28,
    3: 31,
    4: 30,
    5: 31,
    6: 30,
    7: 31,
    8: 31,
    9: 30,
    10: 31,
    11: 30,
    12: 31
}

num = int(input())
print(days[num])


***********************************

Словарь относится к  => изменяемым объектам


***********************************

Перед вами имеется словарь sweet

Ваша задача:

создать строковый ключ weight с целым значением 230
создать строковый ключ have_topping c булевым значением True
изменить значение ключа name на строку SuperCake
изменить значение ключа calories на целое число 350
В качестве ответа распечатайте в конце словарь sweet

sweet = {
    "id": "0001",
    "type": "donut",
    "name": "Cake",
    "ppu": 0.55,
    "calories": 125,
}


sweet['weight'] = 230
sweet['have_topping'] = True
sweet['name'] = 'SuperCake'
sweet['calories'] = 350

print(sweet)


***

Удалите из него ключи ppu и type

Затем выведите словарь sweet в качестве ответа


sweet = {
    "id": "0001",
    "type": "donut",
    "name": "Cake",
    "ppu": 0.55,
    "calories": 125,
}

del sweet['ppu']
del sweet['type']

print(sweet)


**********************************

Что произойдет после запуска следующей программы?

man = {"name": "John", "age": 30, "car": None}

del man[30]
print(man)

=> 	Произойдет ошибка KeyError


**********************************

На вход программе поступает целое число n. Вам необходимо создать словарь, который будет включать в себя ключи от 1 до n, а значениями соответствующего ключа будет значение ключа в квадрате.

В качестве ответа выведите полученный словарь


num = int(input())         			 # получаем число - количество элементов словаря

numbers = {}              			 # создаем пустой словарь для добавления элементов с числами

for i in range(1, num+1):  	#	циклом проходимся по числам от 1 до num(включительно) и добавляем
                                            #  элементы словаря: ключ - число, значение - квадрат числа 
    numbers[i] = i ** 2
    
print(numbers)             		# выводим полученный словарь


**********************************

Напишите программу, которая печатает словарь alphabet, где ключи  - строчные английские символы, а значения - порядковые номера букв в алфавите начиная с 1.

Начало вашего словаря должны быть таким {"a": 1, "b": 2 ... }

В качестве ответа распечатайте полученный словарь alphabet

Весь английский алфавит можно взять в переменной ascii_lowercase из модуля string:



alphabet = {}                  # создаем пустой словарь для добавления английского алфавита

for i in range(26):            				# циклом мы в словарь добавляем элементы словаря: 
									  				# Ключ - английская буква, значение - её порядковый номер
    alphabet[chr(97+i)] = i+1  		# английскую букву мы получаем из таблицы аски 
    													по её id - chr(id) - возвращает букву по id в таблице аски
    													
print(alphabet)                # возвращаем полученный словарь с буквами и их номерами




================== 6.5 Операции со словарями ====================

https://stepik.org/lesson/766881/step/1?unit=769256


***** " Нахождение количества элементов (пар ключ-значение) " *****

Функция len() помогает найти «длину» словаря (под длиной у словаря понимается количество пар «ключ: значение»)

d = {1: 'one', 2: 'two', 3: 'three'}
print(len(d))

lang = {'eng':'Английский', 'ru':'Русский'}
print(len(lang))

empty_dict = {}
print(len(empty_dict))



***** " Проверка наличия ключа в словаре " *****

Мы знаем теперь, что обращаться в словаре можно только по существующему ключу. 
При попытке указать несуществующий ключ вы получите ошибку KeyError. 
Поэтому прежде чем обращаться по ключу необходимо убедиться, что ключ существует. 
В этом поможет оператор in. Он вернет True – когда ключ есть в словаре, в обратном случае – False.  

Если хотите получить противоположный результат, используйте not in


d = {1: 'one', 2: 'two', 3: 'three'}

print(1 in d, 3 in d, 4 in d)
print(5 not in d)
print(2 not in d)
print('-'*15)

lang = {'eng':'Английский', 'ru':'Русский'}

print('eng' in lang)
print('Русский' in lang)
print('Английский' not in lang)


***** " Преобразование в список " *****

При помощи функции list можно преобразовать словарь в список, но есть одна особенность: получится список только из ключей


d = {1: 'one', 2: 'two', 3: 'three'}
list_d = list(d)
print(list_d)
print('-'*15)

lang = {'eng':'Английский', 'ru':'Русский'}
list_lang = list(lang)
print(list_lang)


***** " Сравнение словарей  " *****


Словари можно сравнивать между собой, но сравнение допустимо только 
на равенство == и неравенство !=. 

" Словари будут считаться равными, если они имеют одинаковое количество пар (ключ: значение) 
и при этом в соответствующей паре совпадают и ключ и значение "

d = {1: 'one', 2: 'two', 3: 'three'}
a = {2: 'two', 3: 'three', 1: 'one'}

print(d==a)
print('-'*15)

lang = {'eng':'Английский', 'ru':'Русский'}
lang_2 = {'eng':'Английский', 'rus':'Русский'}
lang_3 = {'eng':'Английский', 'ru':'Russian'}

lang_4 = {}
lang_4['ru'] = 'Русский'
lang_4['eng'] = 'Английский'

print(lang==lang_2)
print(lang!=lang_2)
print(lang==lang_3)
print(lang==lang_4)


" Сравнение при помощи операторов > < >= <= приведет к ошибке TypeError "

d = {1: 'one', 2: 'two', 3: 'three'}
a = {2: 'two', 3: 'three', 1: 'one'}

print(d  >  a)


"Также обратите внимание, что мы сравнивали словари только со словарями. Попытка сравнить словарь с другим типом данных (списком, строкой, числом и т.д.) приведет вновь к ошибке TypeError "



					
					***** " Слияние словарей  " *****
					
Можно объединять пары ключ-значения при помощи операции слияния  <  |  >


" dict_1 | dict_2 "


К значениям словаря, стоящего слева, будут добавляться значения словаря, стоящего справа от знака операции. 

" При совпадении ключей будет браться значения из правого словаря. Поэтому для этой операции важно на каком месте стоят словари "

dict_1 = {'John': 15, 'Rick': 10, 'Misa' : 12 }
dict_2 = {'Bonnie': 18,'Rick': 20}

dict_3 = dict_1 | dict_2
dict_4 = dict_2 | dict_1

print(dict_3)
print('-'*15)
print(dict_4)



************************************

Какое число получим если к словарю person  применить операцию len ?

person = {
    "guid": "ba151b32-0f28-4c6d-b0fd-11a532b881a1",
    "balance": "$1,971.04",
    "age": 30,
    "eyeColor": "green",
    "name": "Brennan Duffy",
    "gender": "male",
    "email": "brennanduffy@viasia.com",
    "phone": "+1 (811) 539-3385",
}

print(len(person))			=> 8


********************

Найдите «длину» словаря account => print(len(person))

***

Словарь можно сравнивать  =>  с другим словарем

***

Что выведет данная программа?

c1 = {'red': 32, 'blue': 35}
c2 = {'red': 9, 'blue': 10}

print(c1 > c2) 		=>  TypeError: '>' not supported between instances of 'dict' and 'dict'

***

Какие операции сравнения можно использовать при сравнении двух словарей =>  ==    !=

***



*********************

Перед вами располагается словарь address

Давайте проверим наличие следующих ключей:

zip_code
longitude
post_code
street_name
number_house

Программа должна проверить наличие ключей и вывести True, если ключ имеется,  или False, если ключ отсутствует.


print('zip_code' in address)
print('longitude' in address)
print('post_code' in address)
print('street_name' in address)
print('number_house' in address)

*******************************

У нас есть словарь currencies, в котором хранятся валюты и их курсы. В словаре представлены далеко не все валюты.

Ваша программа принимает на вход название валюты, проверяет присутствует ли данная валюта в словаре.

Если валюта присутствует необходимо вывести ее курс, если отсутствует - строку Нет данных по <валюта>


currencies = {
    'Argentine Peso': 118362.205708,
    'Australian Dollar': 1586.232315,
    'Bahraini Dinar': 423.780164,
    'Botswana Pula': 13168.450636,
    'Brazilian Real': 5954.781483,
    'British Pound': 834.954104,
    'Bruneian Dollar': 1520.451015,
    'Bulgarian Lev': 1955.83,
    'Canadian Dollar': 1430.54405,
    'Chilean Peso': 898463.818465,
    'Chinese Yuan Renminbi': 7171.445692,
    'Colombian Peso': 4447741.922165,
    'Croatian Kuna': 7527.744707,
    'Czech Koruna': 24313.797041,
    'Danish Krone': 7440.613895,
    'Emirati Dirham': 4139.182587,
    'Hong Kong Dollar': 8786.255952,
    'Hungarian Forint': 355958.035747,
    'Icelandic Krona': 143603.932438,
    'Indian Rupee': 84241.767127,
    'Indonesian Rupiah': 16187150.010697,
    'Iranian Rial': 47534006.535121,
    'Israeli Shekel': 3569.191411,
    'Japanese Yen': 129149.364679,
    'Kazakhstani Tenge': 489292.515538,
    'Kuwaiti Dinar': 340.959682,
    'Libyan Dinar': 5196.539901,
    'Malaysian Ringgit': 4717.485104,
    'Mauritian Rupee': 49212.933037,
    'Mexican Peso': 23130.471272,
    'Nepalese Rupee': 134850.008728,
    'New Zealand Dollar': 1703.649473,
    'Norwegian Krone': 9953.078431,
    'Omani Rial': 433.360301,
    'Pakistani Rupee': 198900.635421,
    'Philippine Peso': 57574.278782,
    'Polish Zloty': 4579.273862,
    'Qatari Riyal': 4102.552652,
    'Romanian New Leu': 4946.638369,
    'Russian Ruble': 86197.012666,
    'Saudi Arabian Riyal': 4226.530892,
    'Singapore Dollar': 1520.451015,
    'South African Rand': 17159.831129,
    'South Korean Won': 1355490.097163,
    'Sri Lankan Rupee': 228245.645722,
    'Swedish Krona': 10439.125427,
    'Swiss Franc': 1037.792217,
    'Taiwan New Dollar': 31334.286611,
    'Thai Baht': 37436.518169,
    'Trinidadian Dollar': 7636.35428,
    'Turkish Lira': 15078.75981,
    'US Dollar': 1127.074905,
    'Venezuelan Bolivar': 511082584.868731
}

currency = input()

if currency in currencies:
    print(currencies[currency])
else:
    print(f' Нет данных по {currency}')


*******************************************

Перед вами словарь account

Ваша задача сохранить в переменную keys список из всех ключей словаря account при помощи функции list

В качестве ответа выведите переменную keys

account = {
  "id": 3136,
  "uid": "1359acc6-f07a-4a2a-984e-3fb809982948",
  "account_number": "0847799459",
  "iban": "GB90XTND56373623909314",
  "bank_name": "ABN AMRO HOARE GOVETT CORPORATE FINANCE LTD.",
  "routing_number": "126602476",
  "swift_bic": "BCYPGB2LHGB"
}

keys = list(account)
print(keys)

*********************************

 Сколько пар ключ-значение будет храниться в переменной result после выполнения слияния словарей ниже?

a = {1: "one", 2: "two"}
b = {2: "dva", 3: "three"}
c = {3: "tri", 4: "four"}

result = a | b | c

Output:
{1: 'one', 2: 'dva', 3: 'tri', 4: 'four'}




***********************************

Перед вами два словаря d1 и d2

Ваша задача выполнить слияние этих словарей в переменную capitals и затем вывести ее на экран

d1 = {'India': 'Delhi',
      'Canada': 'Ottawa',
      'United States': 'Washington D. C.'}

d2 = {'France': 'Paris',
      'Malaysia': 'Kuala Lumpur'}

capitals = d1 | d2

print(capitals)



================= 6.6 Методы словаря ==================


https://stepik.org/lesson/296967/step/1?unit=278695



													===== " Методы словаря " =====

Не забывайте, что словарь - изменяемый объект. 
Поэтому вызов метода словаря может оказывать влияние на состояние самого словаря, у которого вызывается метод, без оператора присвоения.


		===== " Метод clear " =====

Метод .clear() очищает весь словарь. В итоге после вызова получится пустой словарь

d = {1: 'one', 2: 'two', 3: 'three'}


d.clear()
print(d)


		===== " Метод get " =====


Метод get() – позволяет получить значение ключа.  

Нужно указать внутри скобок один аргумент – ключ, значение которого хотим получить. 

Если ключа в словаре нет, то выведет None, но если в метод get() внести второй аргумент, 
то вместо None будет появляться это значение:

d = {1: 'one', 2: 'two', 3: 'three'}

print(d.get(1))
print(d.get(5))

" print(d.get(5, 'No such key')) "





		===== " Метод setdefault " =====


Метод setdefault()  - получает значение ключа. 

" Похож на прошлый метод get(), однако при обращении к несуществующему ключу он вносит в словарь новую пару ключ-значение. "

Значением будет второй аргумент, который был передан в этот метод, либо же None, если в методе только один аргумент:


d = {1: 'one', 2: 'two', 3: 'three'}

print(setdefault(1)) 	=> 	one


print(setdefault(6))  	=>  	" {1: 'one', 2: 'two', 3: 'three', 6: None} "


"**"    print(setdefault(7, 'seven')) 	=>  	" {1: 'one', 2: 'two', 3: 'three', 6: None, 7: 'seven'} "




		===== " Метод pop " =====


"Метод pop() – возвращает значение, находящееся под указанным ключом, а из самого словаря удаляется пара с данным ключом:"


d = {1: 'one', 2: 'two', 3: 'three'}


deleted_value = d.pop(1)
print(f'Deleted value =>  {deleted_value}')			# Deleted value =>  one

print(d)					# {2: 'two', 3: 'three'}


"Вызов метода без указания ключа, либо же без существующего ключа, приводит к ошибке TypeError."




		===== " Метод popitem " =====
		
		
Метод popitem() удалит и вернет двойной кортеж (key, value) из словаря. 

Пары возвращаются с конца словаря, в порядке LIFO (последним пришёл - первым ушёл).		

d = {1: 'one', 2: 'two', 3: 'three'}

pop_item = d.popitem()
print(pop_item) 					# (3, 'three')

print(d)									# {1: 'one', 2: 'two'}


print('-'*15)

lang = {}

lang['ru'] = 'Русский'
lang['eng'] = 'Английский'

first = lang.popitem()
print(first)								# ('eng', 'Английский')

second = lang.popitem()
print(lang)								# {}


" При попытке удаления элементов из пустого словаря возникает ошибка KeyError. "


		
		
		===== " Метод keys " =====
		
Метод keys() позволяет получить все ключи словаря.

d = {1: 'one', 2: 'two', 3: 'three'}
print(d.keys())

keys = list(d.keys())
print(keys)

lang = {'eng':'Английский', 'ru':'Русский'}
print(lang.keys())


		
		
		===== " Метод values " =====
		
" Метод values() позволяет получить все значения словаря "		

d = {1: 'one', 2: 'two', 3: 'three'}
print(d.values())

vals = list(d.values())
print(vals)

lang = {'eng':'Английский', 'ru':'Русский'}
print(lang.values())

		
		
		===== " Метод items " =====
		
" Метод items() – возвращает коллекцию, в которой содержатся все пары «ключ-значение» в виде кортежей "

d = {1: 'one', 2: 'two', 3: 'three'}
print(d.items())						# dict_items([(1, 'one'), (2, 'two'), (3, 'three')])

couples = list(d.items())
print(couples)						# [(1, 'one'), (2, 'two'), (3, 'three')]

print('-'*15)

lang = {'eng':'Английский', 'ru':'Русский'}
print(lang.items())



		===== " Метод update " =====

" Метод update() обновляет словарь элементами из другого словаря. "

Другими словами, метод сливает(мержит от английского «merge») один словарь в другой: добавляются новые ключи из другого словаря
" при совпадении ключей записывается значение из переданного словаря "


d = {1: 'one', 2: 'two', 3: 'three'}
w = {4: 'four', 5: 'five'}

d.update(w)
print(d)						# {1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five'}




lang = {'eng':'Английский', 'ru': 'Русский'}
other = {'esp': 'Spanish', 'ru': 'Rus'}

lang.update(other)
print(lang) 				# {'eng': 'Английский', 'ru': 'Rus', 'esp': 'Spanish'}




"Словари относятся к коллекциям как и списки, строки и кортежи. Все коллекции объединяет то, что по их элементам можно итерироваться: обходить элементы коллекции при помощи цикла for"

lang = {'eng': 'Английский',
        'ru': 'Русский',
        'fra': 'Французский',
        'esp': 'Испанский'}
        
for item in lang:
  print(item)  


"По умолчанию в словаре используются ключи в качестве значений при итерации цикла for"


Повторюсь, именно ключи словаря используются при итерации. При помощи метода keys мы могли бы явно указать, что итерироваться будем именно по ключам словаря


lang = {'eng': 'Английский',
        'ru': 'Русский',
        'fra': 'Французский',
        'esp': 'Испанский'}
        
for key in lang.keys():
  print(key)      
  
  
# Output: 	=>	eng ru fra esp
  
Но что, если мы хотим итерироваться не по ключам, а по значениям словаря. Так тоже можно делать, причем двумя способами:

" 1)  итерироваться по ключам, и обращаться через них по значениям "

lang = {'eng': 'Английский',
        'ru': 'Русский',
        'fra': 'Французский',
        'esp': 'Испанский'}
        
for key in lang.keys():
  print(lang[key])


# Output:  =>  Английский Русский Французский Испанский 



" 2)  использовать метод values"

lang = {'eng': 'Английский',
        'ru': 'Русский',
        'fra': 'Французский',
        'esp': 'Испанский'}
        
for value in lang.values():
  print(value)   



" А можно сразу итерироваться и по ключу и по его значению, спросите Вы? Конечно! Используйте метод items  "



        
for item in lang.items():
  print(item, f'Key = {item[0]}, value = {item[1]}')


('eng', 'Английский')  Key = eng, value = Английский
('ru', 'Русский')  Key = ru, value = Русский
('fra', 'Французский')  Key = fra, value = Французский
('esp', 'Испанский')  Key = esp, value = Испанский



" Метод items будет нам предоставлять кортеж, состоящий из пары ключ-значение. В этой паре всегда ключ идет на первом месте, значение - на втором. Мы можем достать их по индексам, либо лучше сразу распаковать в две переменные в самом цикле for "


for key, value in lang.items():
  print(key, value)


eng Английский
ru Русский
fra Французский
esp Испанский


***************************************

Есть два словаря, нужно в словарь d2 объеденить словарь d1 при помощи метода update

В качестве ответа выведите словарь d2


d1 = {'a': 100, 'b': 200, 'c': 333}
d2 = {'x': 300, 'y': 200, 'z': 777}

d2.update(d1)

print(d2)


***************************************

Система регистрации



n = int(input())         			# получаем число - сколько будет введено запросов
arhiv = {}               			# создаем пустой словарь с использованными запросами

for i in range(n):       			# циклом получаем определенное количество запросов и проверяем их 
										наличие в базе
										
    a = input()          			# получаем запрос
    if a not in arhiv:   			# если запроса нет в базе данных, то добавляем его в базу и выводим ОК
        arhiv[a] = 1     			# добавляем в словарь. 
        									Ключ - запрос, значение - число сколько раз его использовали
        									
        print('OK')      			# выводим сообщение ОК
    else:                				# иначе, если уже есть в словаре
        print(f'{a}{arhiv[a]}')			# мы выводим данный запрос, но с циферкой на конце
        										(сколько раз его уже использовали)
        arhiv[a] += 1    
        
        
 ~~
 
d = {}

for name in [input() for i in range(int(input()))]:     # массив входных данных
    if d.get(name) is None:             # dict.get() возвращает None, если ключ не найден
        d[name] = 0                     # ключ не найден --> инициализируем счетчик
        print('OK')
    else:
        d[name] += 1                    # ключ встретился --> увеличиваем счётчик
        print(name, d[name], sep='')
        
        
 ~~ 
 
 data = {}

for i in range(int(input())):
    i = input()
    if i not in data:
        print('OK')
        data[i] = data.get(i, 0) + 1
    else:
        print(i + str(data[i]))
        data[i] += 1
        
 ~~
requests = [input() for user in range(int(input()))]

users = []

for user in requests:
    print('OK' if users.count(user) == 0 else user + str(users.count(user)))
    users.append(user)

 ~~ 
 logins = {}
n = int(input())
for i in range(n):
    name = input()
    if name not in logins:
        logins[name]=0
        print ('OK')
    else:
        logins[name]+=1
        print(name+str(logins[name]))
 
 
 
~~
    
def test_user(users, name):
    if name in users:
        count = 1
        new_name = f'{name}{count}'
        while new_name in users:
            count += 1
            new_name = f'{name}{count}'
        users.setdefault(new_name)
        return new_name
    users.setdefault(name)
    return "OK"


n = int(input())
users = {}
for x in range(n):
    name = input()
    print(test_user(users, name))   

~~

names = {}

for i in range(int(input())):
    name = input()
    names[name] = names.get(name, -1) + 1
    print('OK' if names[name] == 0 else name + str(names[name]))
    
    
~~

d= {}

for _ in range(int(input())):
  name = input()
  if name in d:
    d[name]+=1
  else:
    d[name]=0
    
  print(f'{name}{d[name]}'if d[name]else 'OK')

~~

dic = {}

for i in range(int(input())):
    a = input()
    if a not in dic:
        dic[a] = 0
        print('OK')
    else:
        dic[a] = dic[a] + 1
        print(a + str(dic[a]))

~~

n = int(input())
a = []
base = {}
for _ in range(n):
    a.append(input().lower())

for i in range(n):
    if a[i] not in base:
        base[a[i]] = ''
        print('OK')
    else:
        j = 1
        while a[i] + str(j) in base:
            j += 1
        base[a[i] + str(j)] = ''
        print(a[i] + str(j))


~~

c = int(input())
a = {}
for i in range(c):
    e = input()
    if e not in a.keys():
        a[e] = 'OK'
    else:
        for i in range(1, len(a)+1):
            if (e + str(i)) not in a.keys():
                e += str(i)
                a[e] = e
                break

print(*a.values(), sep='\n')        
        
~~

a = int(input())
d = {}
x = 1
for i in range(a):
    key = input()
    if key in d.values():
        while key + str(x) in d.values():
            x += 1
        d.setdefault(i, key + str(x))
        x = 1
    else:
        d.setdefault(i, key)
        x = 1

for i in d.values():
    if 'a' <= i[-1] <= 'z':
        print('OK')
    else:
        print(i)
        
        
~~

names = {}

for _ in range(int(input())):
    i = input()
    
    if i in names:
        print(f'{i}{names[i]}')
        names[i] += 1
    else:
        names[i] = 1
        print('OK')


=========================================



Переменные countries соединяют ряд стран с тремя крупнейшими городами каждой страны. 

Программе на вход будет поступать название города в переменную city. И ваша задача найти какой стране принадлежит введенный город. Если страна успешно найдена, необходимо вывести сообщение:


countries = {
    "Sweden": ["Stockholm", "Göteborg", "Malmö"],
    "Norway": ["Oslo", "Bergen", "Trondheim"],
    "England": ["London", "Birmingham", "Manchester"],
    "Germany": ["Berlin", "Hamburg", "Munich"],
    "France": ["Paris", "Marseille", "Toulouse"]
}

city = input()


for key, values in countries.items():

    if city in values:
        print(f'INFO: {city} is a city in {key}')
        break
else:            
    print(f'ERROR: Country for {city} not found')
    

~~

city = input()
text = f"ERROR: Country for {city} not found"

for i in countries:
    if city in countries[i]:
        text = f"INFO: {city} is a city in {i}"
        
print(text)


~~

for country, cities in countries.items():

    if city in cities:
        print(f'INFO: {city} is a city in {country}')
        break
else:
    print(f'ERROR: Country for {city} not found')


~~

d = dict([(city, country) for country, cities in countries.items() for city in cities])

city = input()

if city in d:
    print(f'INFO: {city} is a city in {d[city]}')
else:
    print(f'ERROR: Country for {city} not found')
    
~~

city = input()

country = [k for k, v in countries.items() if city in v]

print(f'INFO: {city} is a city in {country[0]}' if country else f'ERROR: Country for {city} not found')


~~

city = input()

print(*[f'INFO: {city} is a city in {i}' for i, cities in countries.items() if city in cities] or [f'ERROR: Country for {city} not found'])

~~

city = input()

print(f'INFO: {city} is a city in {d[0]}' if len(d := [i for i in countries if city in countries[i]]) == 1
      else f'ERROR: Country for {city} not found')
      
      

****************************************

Перед вами словарь user

При помощи метода pop переименуйте в нем следующие ключи:

ключ password в ключ secret
ключ last_name в ключ surname
Выводить ничего не нужно, только изменить ключи словаря



" # переименовываем ключ(удаляем старый элемент словаря и создаем новый с новым ключем и старым значением) "

user['secret'] = user.pop('password') 

" # переименовываем ключ(удаляем старый элемент словаря и создаем новый с новым ключем и старым значением)"

user['surname'] = user.pop('last_name') 

# from pprint import pprint
# pprint(user)



~~

user['secret'], user['surname'] = user.pop('password'), user.pop('last_name')

~~

for key, value in list(user.items()):
    if key == 'password':
        user['secret'] = value
        user.pop(key)
    if key == 'last_name':
        user['surname'] = value
        user.pop(key)


~~

d = {}

for k,v in user.items():

    if k == 'password':
        d['secret'] = v
    elif k == 'last_name':
        d['surname'] = v
    else:
        d[k] = v
        
user = d


~~

user.setdefault('secret', user.pop('password'))
user.setdefault('surname', user.pop('last_name'))

~~

new_keys = ('secret', 'surname')
old_keys = ('password', 'last_name')

for new_key, old_key in zip(new_keys, old_keys):
    user.setdefault(new_key, user.pop(old_key))
    
~~

keys, values = list(user), list(user.values())
keys[keys.index("password")], keys[keys.index("last_name")] = "secret", "surname"

user = dict(zip(keys, values))

print(user)

~~

user_list = list(user.items())

user_list[2], user_list[4] = list(user_list[2]), list(user_list[4])
user_list[2][0], user_list[4][0] = 'secret', 'surname'

user = dict(user_list)
print(user)


~~

a={}

for key,val in user.items():
    if key=='password':
        a.setdefault('secret',val)
    elif key=='last_name':
        a.setdefault('surname',val)
    else:
        a.setdefault(key,val)

user.clear()
user=a

print(user)


~~

user.pop("password")
user.pop("last_name")
user.setdefault("secret","SyUpfo1ljm")
user.setdefault("surname","Wehner")

~~

del_key_1 = user.pop('password')
del_key_2 = user.pop('last_name')

user.update(secret=del_key_1, surname=del_key_2)

~~

replace_keys = dict(password='secret', last_name='surname')

[user.setdefault(new, user.pop(old)) for old, new in replace_keys.items()]


************************************

Напишите код для преобразования списка из целых чисел произвольной длины в словарь, вложенность которого зависит от длины списка.

Например, если перед вами был бы такой список 

[100, 55, 77, 55, 89]
то он должен превратиться в такой словарь

{100: {55: {77: {55: 89}}}}



list_inp = list(map(int, input().split()))
dic = {}

x = len(list_inp) - 1

while x != 0:

    if len(dic) == 0:
        dic = {list_inp[x - 1]: list_inp[x]}
    else:
        dic = {list_inp[x - 1]: dic}
    x -= 1

print(dic)

~~

a = list(map(int, input().split()))

d = a[-1]

for i in a[-2::-1]:
    d = {i: d}
    
print(d)


~~

li = [int(i) for i in input().split()]

d = li.pop()

while li:
    d = {li.pop(): d}
    
print(d)


~~

def nested_dict(lst):
    return {lst[0]: nested_dict(lst[1:])} if len(lst) > 2 else dict([lst])
    

lst = list(map(int, input().split()))    
print(nested_dict(lst))   


~~

from functools import reduce

data = tuple(map(int, input().split()[::-1]))

print(reduce(lambda a, b: {b: a}, data[1:], data[0]))


~~

lst = list(map(int, input().split()))

d = {lst[-2]: lst[-1]}

for i in lst[-3::-1]:
    d = {i: d}
    
print(d)


~~

lst = [*map(int, input().split())]
d = {lst[-2]: lst[-1]}

lst = lst[:-2]

while lst:
    d = {lst[-1]: d}
    lst = lst[:-1]
    
print(d)


~~

t = list(map(int, input().split()))

for i in range(len(t) - 1):
    t.append({t.pop(-2): t.pop(-1)})

print(*t)

~~

from functools import reduce

print(reduce(lambda x, y: {y: x}, list(map(int, input().split()))[::-1]))

~~

source = list(map(int, input().split()))
result = dict()

for i in range(len(source) - 1, 0, -1):
    key, value = source[i - 1: i + 1]
    result = {key: result or value}
    
print(result)

    The first line of code reads in a line of space-separated integers from the user using the input() function, converts them to integers using the map() function, and stores them in a list called source.

    The second line of code initializes an empty dictionary called result.

    The for loop starts iterating through the source list backwards, from the second-to-last element to the first element.

    Inside the loop, the line key, value = source[i - 1: i + 1] assigns the two adjacent elements of the source list to the variables key and value. The source[i - 1: i + 1] expression creates a new list containing the element at index i-1 and the element at index i.

    The next line of code creates a new dictionary called result with a single key-value pair. The key is the key variable from step 4, and the value is either the result dictionary from the previous iteration of the loop (if it's not empty), or the value variable from step 4 (if result is empty).

    Finally, the print() statement prints out the result dictionary.

Overall, this code seems to be taking a list of integers as input, and generating a new dictionary from the list where the key is each integer in the list and the value is the integer immediately following it.

~~

def transferDict(lst: list) -> dict:
    """код для преобразования списка из целых чисел произвольной длины в словарь"""
    result: dict = {}
    if len(lst) == 2:
        result[lst[0]] = lst[1]
        return result
    result[lst[0]] = transferDict(lst[1:])
    return result


print(transferDict([int(i) for i in input().split()]))


~~

input_list = list(map(int, input().split()))
while len(input_list) > 1:
    input_list[-2] = {input_list[-2]: input_list[-1]}
    input_list.pop()
print(*input_list)


~~

l = list(map(int, input().split()))
d = {l[-2]: l[-1]}
for i in range(-3, -len(l)-1, -1):
    d = {l[i]: d}
print(d)


~~

l = list(map(int,input().split()))
my_dict={}
count=-3
for i in l[:-1]:
    if len(my_dict)<1:
        my_dict={l[-2]:l[-1]}
    else:
        my_dict={l[count]:my_dict}
        count-=1
print(my_dict)



================ 6.7 Ситуации, где полезно использовать словарь =================


https://stepik.org/lesson/296968/step/2?unit=278696



		===== " Подсчет количества объектов " =====

Словари часто используются для подсчета значений. При таком использовании ключами словаря будут объекты подсчета, а значение ключа – количество появлений этих объектов. 


" Пример подсчёта количества элементов в строке: подсчитаем сколько раз встретилась каждая буква в строке. "


s = input('Введите строку! Подсчитваем ее буквы: ')

d = {}

for i in s:
    if i in d:
        d[i] += 1
    else:
        d[i] = 1
        
print(d)

for letter, count in d.items():
    print(letter, count)


В данном алгоритме если в нашем словаре есть уже такой элемент, то мы увеличиваем счётчик на 1, 
а если этого элемента не было, то мы создавали его как ключ и ставим счётчик на 1 (поскольку это его первое появление)


Давайте оптимизируем:

при помощи метода isalpha() у строк оставим только буквы, 
тем самым исключим числа и знаки препинания

вспомним о методе get у словаря: с помощью метода get() можно получить значение, 
которое лежало по данному ключу, а в случае, если ключа не было, 
возвращается 0 и добавляем единицу


s = input('Введите строку! Подсчитваем ее буквы: ')

d = {}

for i in s:
     if i.isalpha():
        d[i] = d.get(i, 0) + 1
        
print(d)

for letter, count in d.items():
    print(letter, count)


This code prompts the user to input a string and stores it in the variable s. 

It then creates an empty dictionary d to store the count of each letter in the string.

The for loop iterates over each character i in the string s. 

The if statement checks if the character is a letter using the isalpha() method. 

If it is a letter, the code then checks if the letter is already in the dictionary d using the get() method.

If the letter is already in the dictionary, the code increments the count for that letter by 1. 

If the letter is not in the dictionary, the code adds it to the dictionary with a count of 1.

After the loop completes, the code prints out the dictionary d. 

The second for loop then iterates over each key-value pair in the dictionary d using the items() method. 

It prints out each key-value pair, with the key representing the letter and the value representing the count of that letter in the string.

***

 d[i] = d.get(i, 0) + 1
 
 d.get(i, 0) is a dictionary method that returns the value associated with the key i if it exists in the dictionary d. If the key i is not in the dictionary d, it returns the default value 0.

"So, d[i] = d.get(i, 0) retrieves the current count of the letter i in the dictionary d, or sets it to 0 if the letter is not already in the dictionary."

d[i] = d.get(i, 0) + 1 then increments the count of the letter i by 1 and stores the new count in the dictionary d. The expression d.get(i, 0) + 1 first retrieves the current count of the letter i using d.get(i, 0), and then adds 1 to it. Finally, the updated count is assigned to the key i in the dictionary d using the assignment operator =.





		===== " Словари помогают установить соответствие между объектами " =====

Рассмотрим ситуацию, когда необходимо установить соответствие между английским словом и его русским переводом.

words = {}

while True:

  s = input('Введите английское слово: ')
  
  if s in words:
      print("Слово", s, 'переводится как', words[s])
  else:
      print("Введите перевод слова", s)
      words[s] = input()
      


"В итоге мы вводим слово, если оно есть в словаре, то мы выводим значение по заданному ключу (перевод слова), если же такого ключа нет, то мы просим ввести перевод и добавляем в словарь пару ключ-значение"


	===== Хранение данных об объектах ======
	

contacts = {
    'John Kennedy': {
        'birthday': '29 may 1917', 'city': 'Brookline',
        'phone': None, 'children': 3
    },
    'Arnold Schwarzenegger': {
        'birthday': '30 july 1947', 'city': 'Gradec',
        'phone': 555-555-555, 'children': 5
    },
    'Donald John Trump': {
        'birthday': '14 july 1946', 'city': 'New York',
        'phone': 777-777-777, 'children': 4
    }
}



persons = ['John Kennedy', 'Arnold Schwarzenegger', 'Donald John Trump']

for person in persons:
    print(person, contacts[person])
    print('-'*15)
    
print('/'*25)


Output:

John Kennedy {'birthday': '29 may 1917', 'city': 'Brookline', 'phone': None, 'children': 3}
---------------
Arnold Schwarzenegger {'birthday': '30 july 1947', 'city': 'Gradec', 'phone': -555, 'children': 5}
---------------
Donald John Trump {'birthday': '14 july 1946', 'city': 'New York', 'phone': -777, 'children': 4}



" к примеру вывести только имя и день рождения: "

for person in persons:
    print(person, contacts[person]['birthday'])
    
    
 Также у нас есть возможность с помощью цикла for так сказать достать все эти данные и создать для них переменные:
  
persons = ['John Kennedy', 'Arnold Schwarzenegger', 'Donald John Trump']

for person in persons:

    birthday = contacts[person]['birthday']
    city = contacts[person]['city']
    phone = contacts[person]['phone']
    children = contacts[person]['children']
    print(person,  city, birthday)
    
    



contacts = {
    'John Kennedy': {
        'birthday': '29 may 1917', 'city': 'Brookline',
        'phone': None, 'children': 3
    },
    'Arnold Schwarzenegger': {
        'birthday': '30 july 1947', 'city': 'Gradec',
        'phone': 555-555-555, 'children': 5
    },
    'Donald John Trump': {
        'birthday': '14 july 1946', 'city': 'New York',
        'phone': 777-777-777, 'children': 4
    }
}

persons = ['John Kennedy', 'Arnold Schwarzenegger', 'Donald John Trump']

for person in persons:

    print('-'*15)
    print(person)
    
    for data in contacts[person]:
        print(data, contacts[person][data])
        
        

*************************************************

Перед вами словарь workers

Ваша задача поднять зарплату Бреду до 8500 и затем вывести измененный словарь workers        
        
workers = {
    'employer1': {'name': 'Jhon', 'salary': 7500},
    'employer2': {'name': 'Emma', 'salary': 8000},
    'employer3': {'name': 'Brad', 'salary': 500}
}

workers['employer3']['salary'] = 8500
print(workers)
        
        
~~

for worker in workers:
    if workers[worker]['name'] == 'Brad':
        workers[worker]['salary'] = 8500
        
print(workers)  

~~

for worker in workers.values():
    if worker['name'] == 'Brad':
        worker['salary'] = 8500
        break

print(workers)
        
        
~~

workers['employer3']['salary'] += 8000
print(workers)


~~

employers = [i for i in workers]
for employer in workers:
    if workers[employer]['name'] == 'Brad':
        workers[employer]['salary'] = 8500
print(workers)


~~

sp = list(workers)

for key in sp:
    if workers[key]['name'] == 'Brad':
        workers[key]['salary'] = 8500
print(workers)


~~

for i in workers:
    for j in workers[i]:
        if workers[i][j] == 'Brad':
            workers[i]['salary'] = 8500
            
print(workers)


~~

x = {workers[i].update({'salary': 8500}) for i in workers if workers[i]['name'] == 'Brad'}

print(workers)


~~

cop = ["employer1","employer2","employer3"]

for i in cop:
    for j in workers[i]:
        if workers[i][j] == "Brad":
            workers[i]["salary"] = workers[i].get("salary") + 8000
            
print(workers)

~~

workers['employer3'].update({'salary': 8500})

print(workers)
 
 
************************************************

Теперь ваша задача научиться использовать словарь для подсчета количества. 

Вашей программе поступает на вход строка, вам необходимо подсчитать сколько раз встретилась каждая буква в этой строке без учета регистра, при этом цифры и символы пунктуации нужно пропустить. 

Ответ нужно сохранить в словаре, в котором ключ - буква, а значение - количество раз, сколько эта буква встретилась в строке. 

В качестве ответа нужно вывести словарь


s = input().lower()  			# получаем строку для подсчета букв и форматируем методом в нижний регистр
d = {}  								# создаем пустой словарь для добавления встречающихся букв и мих количества

for i in s:  							# циклом проходимся по строке(берём каждую букву)
    if i.isalpha():  			# проверяем если это буква, то проверяем встречалась ли она, 
    									если да то к количеству прибавляем 1, иначе добавлем в словарь
        d[i] = d.get(i, 0) + 1
        
print(d) 

input: aabbbc
output: {'a': 2, 'b': 3, 'c': 1}
        
        
~~

s = input().lower()
d = {i: s.count(i) for i in s if i.isalpha()}
print(d)

~~

d = {}

for i in input().lower():
    if i.isalpha():
        d[i] = d.get(i, 0) + 1
        
print(d)

~~

d = {}

for i in [i.lower() for i in input() if i.isalpha()]:
    d[i] = d.get(i, 0) + 1
    
print(d)


~~        
      
txt = [i for i in input().lower() if i.isalpha()]

my_dict = {i: txt.count(i) for i in txt}

print(my_dict)


~~  
        
import re

from collections import Counter

print(dict(Counter(re.sub(r'[^a-z]', '', input().lower()))))

~~

s = input().lower()
print({ch: s.count(ch) for ch in s if ch.isalpha()})

~~

from string import ascii_lowercase

d = dict()

for _ in input().lower():
    if _ in ascii_lowercase:
        d[_] = d.get(_, 0) + 1
        
print(d)
        
~~

from string import ascii_lowercase
d = dict()
for _ in input().lower():
    if _ in ascii_lowercase:
        d[_] = d.get(_, 0) + 1
print(d)        
        
~~

s = input().lower()
d = {}
for i in s:
    if i.isalpha() and i not in d:
        d[i] = s.count(i)
print(d)

~~

from collections import Counter

print(dict(Counter(i for i in input().lower() if i.isalpha())))


~~~

from collections import Counter
print(dict(Counter(x for x in input().lower() if x.isalpha())))

~~~

word = ''.join(input().split())
d = {}
for i in word.lower():
    if i.isalpha() == True:
        d[i] = d.get(i, 0) + 1
        
print(d)


~~

n=input().lower()
print({i : n.count(i) for i in n if i in 'abcdefghijklmnopqrstuvwxyz'})


*****************************************

Во сколько обойдется данная покупка? Хотим купить все товары в указанном количестве

supermarket = {
    "milk": {"quantity": 20, "price": 1.19},
    "biscuits": {"quantity": 32, "price": 1.45},
    "butter": {"quantity": 20, "price": 2.29},
    "cheese": {"quantity": 15, "price": 1.90},
    "bread": {"quantity": 15, "price": 2.59},
    "cookies": {"quantity": 20, "price": 4.99},
    "yogurt": {"quantity": 18, "price": 3.65},
    "apples": {"quantity": 35, "price": 3.15},
    "oranges": {"quantity": 40, "price": 0.99},
    "bananas": {"quantity": 23, "price": 1.29}
}

Укажите ниже, какую итоговую сумму необходимо будет заплатить

The total amount that needs to be paid is: 528.37


total_cost = 0

for item, info in supermarket.items():
    quantity = info["quantity"]
    price = info["price"]
    item_cost = quantity * price
    total_cost += item_cost

print("The total amount that needs to be paid is:", total_cost)


****************************************

Cтрока S1 называется анаграммой строки S2, если она получается из S2 перестановкой символов.

Программа получает на вход две строки S1 и S2. Если строка S1 является анаграммой строки S2 нужно вывести YES, в противном случае — NO



s = input().lower()     # получаем строку для подсчета букв и форматируем методом в нижний регистр
d = {}                        # создаем пустой словарь для добавления встречающихся букв и мих количества

for i in s:                   # циклом проходимся по строке(берём каждую букву)
     if i.isalpha():         # проверяем если это буква, то проверяем встречалась ли она, если да то 
                                 # к количеству прибавляем 1, иначе добавлем в словарь
        d[i] = d.get(i, 0) + 1
         
s2 = input().lower()    # получаем вторую строку для подсчета букв и форматируем методом в нижний регистр
d2 = {}                      # создаем пустой словарь для добавления встречающихся букв и мих количества
for i in s2:                 # циклом проходимся по строке(берём каждую букву)
     if i.isalpha():        # проверяем если это буква, то проверяем встречалась ли она, если да то к количеству 
                                # прибавляем 1, иначе добавлем в словарь
        d2[i] = d2.get(i, 0) + 1
         
if d == d2:             # проверяем равны ли словари с буквами и их количества двух строк. 
                              # Если они равны, то выводим YES, иначе NO
    print('YES')
else:
    print('NO')


~~

s1 = input()
s2 = input()

a = {}
b = {}

for i in s1:
    a[i] = a.get(i, 0) + 1
    
for i in s2:
    b[i] = b.get(i, 0) + 1
    
print('YES' if sorted(a.items()) == sorted(b.items()) else 'NO')   


~~

from collections import Counter

print(('NO', 'YES')[Counter(input()) == Counter(input())])

"~~"

from collections import Counter
from operator import eq

print(('NO', 'YES')[eq(*[Counter(input()) for _ in range(2)])])

~~

print('YES' if sorted(input()) == sorted(input()) else 'NO')

~~

s1, s2 = input(), input()

d1 = {i: s1.count(i) for i in s1}
d2 = {i: s2.count(i) for i in s2}

print('YES' if d1 == d2 else 'NO')      

~~

cnt = {}

for ch in input():
    cnt[ch] = cnt.get(ch, 0) + 1
    
for ch in input():
    cnt[ch] = cnt.get(ch, 0) - 1
    
    if cnt[ch] < 0:
        print('NO')
        break
else:
    print('YES')
  
  
~~

def letter_counter(s: str) -> dict:
    d = dict()
    for c in s:
        d[c] = d.get(c, 0) + 1
    return d
        
d1 = letter_counter(input())
d2 = letter_counter(input())

print('YES' if d1 == d2 else 'NO')


~~

a = input().lower()
b = input().lower()

rez = "YES"

dict_a = sorted({i:a.count(i) for i in a}.items())
dict_b = sorted({i:b.count(i) for i in b}.items())

if dict_b != dict_a:
    rez = "NO"
print(rez)

~~

a, b = input(), input(); 

print('YES' if (d := {i: a.count(i) for i in a}) == (d1 := {i: b.count(i) for i in b}) else 'NO')

~~


************************************************

					Азбука Морзе
					
Вам дан английский текст. Закодируйте его с помощью азбуки Морзе.Каждая буква заменяется на последовательность точек и тире. В качестве тире используйте обычный дефис: «-», а в качестве точки — точку «.». Например, буква «g» превратится в трёхсимвольную строку «--.». Ниже в переменной morze для вашего удобства хранится словарь соответствия английских букв коду Морзе. 


morze = {
    'a': '•—', 'b': '—•••', 'c': '—•—•', 'd': '—••',
    'e': '•', 'f': '••—•', 'g': '——•', 'h': '••••',
    'i': '••', 'j': '•———', 'k': '—•—', 'l': '•—••',
    'm': '——', 'n': '—•', 'o': '———', 'p': '•——•',
    'q': '——•—', 'r': '•—•', 's': '•••', 't': '—',
    'u': '••—', 'v': '•••—', 'w': '•——', 'x': '—••—',
    'y': '—•——', 'z': '——••'
}
         
         
text = input().lower().split()   			# получаем строку для кодировки и опускаем в нижний регистр 
														т.к. и строчные и заглавные кодируются одинаково и разбиваем 
														на список по словам
														
for i in text:                   					# проходимся по списку со словами

    for j in i:                  						# проходимся по буквам слова
    
        print(morze[j], end=' ') 			# обращаемся к словарю буквой в качестве ключа и выводим шифр 
        												этой буквы
        												
    print()                      						# после каждой буквы переходим на новую строку



 ~~
 
 
 for i in input().lower().split():
    print(*[morze[j] for j in i])
    
~~

s = input().lower().split()

for i in s:
    for j in i:
        print(morze[j] + ' ', end='')
        
    print()
    

~~

line = input().lower().split()

for word in line:
    for letter in word:
        print(morze[letter], end=" ")
        
    print()        
    
    
~~

s = [' '.join([morze[el] for el in list(x)]) for x in input().lower().split()]
print(*s, sep = '\n')

~~

[print(' '.join(morze[c] for c in w.lower())) for w in input().split()]

~~

x = (input().lower()).split()   					#преобразуем строку в список слов разделенных пробелами

for i in x: 												#обходим список по словам
    y = ''  												#промежуточная строка в котор.добавляется шифр каждого слова 
    														(она очищается перед новым словом)
    														
    for j in i: 											#обходим слово по символам
        if j in morze: 								#условие добавления шифра в промежуточную строку
            y += morze[j]+' '
    print(y)												#вывод промежуточной строки после обхода каждого слова
    
 
 ~~
 
 s = input().lower()

for i in s:
    for j in i:
        if j == ' ':
            print()
        else:
            print(morze[j], end=" ")
            
            
            
 *********************************************************
 
 persons= [
    ('Allison Hill', 334053, 'M', '1635644202'),
    ('Megan Mcclain', 191161, 'F', '2101101595'),
    ('Brandon Hall', 731262, 'M', '6054749119'), 
    ('Michelle Miles', 539898, 'M', '1355368461'),
    ('Donald Booth', 895667, 'M', '7736670978'), 
    ('Gina Moore', 900581, 'F', '7018476624'),
    ('James Howard', 460663, 'F', '5461900982'), 
    ('Monica Herrera', 496922, 'M', '2955495768'),
    ('Sandra Montgomery', 479201, 'M', '5111859731'), 
    ('Amber Perez', 403445, 'M', '0602870126')
]

data = {}             					# создаем пустой список для добавления туда элементов словаря o людях

for i in persons:     				# проходимя по списку и берём каждый кортеж

    data[i[0]] = {'salary': i[1], 'gender': i[2], 'passport': i[3]}    
    
    # в качестве ключа берем первое значение из кортежа - имя и фамилия, 
    а в значение записываем словарь с данными   
    
    
~~

data = {e[0]: {'salary': e[1], 'gender': e[2], 'passport': e[3]} for e in persons}

~~

s = ['salary', 'gender', 'passport']

data = {}

for i in persons:
    data[i[0]] = dict(zip(s, i[1:]))    
    
    
~~

data = {
    name: {'salary': salary, 'gender': gender, 'passport': passport}
    for name, salary, gender, passport in persons}
    
~~

data = {}
for i in persons:
    data[i[0]]={'salary': i[1], 'gender': i[2], 'passport': i[3]}
    
~~

data = {}

for i in persons:
    data[i[0]] = dict(salary=i[1], gender=i[2], passport=i[3])
    

~~

data = {name: {'salary': salary, 'gender': gender, 'passport': passport} for name, salary, gender, passport in persons}


~~

data = {}

for key in range(len(persons)):
    data[persons[key][0]] = {'salary': persons[key][1], 'gender': persons[key][2], 'passport': persons[key][3]}
    
    
*********************************************
У словаря data следующая структура ключей, хорошо рассмотрите ее.

{
  "my_friends": {
    "count": ...,
    "people": [
      {
        "first_name": value,
        "id": value,
        "last_name": value,
      },
      {
        "first_name": value,
        "id": value,
        "last_name": value,
      }, 
      ......
    ]
  }
}
Ваша задача получить значения ключа first_name у всех элементов и вывести их в алфавитном порядке, каждое имя с новой строки

P.S. Чтобы посмотреть содержимое словаря data воспользуйтесь следующим кодом:




from pprint import pprint
pprint(data)



#    циклом проходимся по списку(в котором хранятся словари), который является значением при обращении к словарю data по ключу my_friends затем в нем обращаемся к ключу people

# так как i - каждую итерацию это словарь, то добавляем в наш список значение этого словаря по ключу first_name

# выводим полученный список распаковав и отсортировав (каждое значение на новой строчке)


sp = []

for i in data['my_friends']['people']:
    sp.append(i['first_name'])
    
print(*sorted(sp), sep='\n')


~~

first_names = []
for i in data['my_friends']['items']:
    first_names.append(i['first_name'])
for i in sorted(first_names):
    print(i)
    
    
~~

print(*sorted([x.get('first_name') for x in data.get('my_friends').get('items')]), sep='\n')

~~

a = []

for i in range(len(data["my_friends"]["items"])):
    a.append(data["my_friends"]["items"][i]["first_name"])
    
a.sort()
for i in a:
    print(i)
    
    
    
    
===============   6.8 Генераторы словарей  =================


Генератор словаря необходим для быстрого и удобного создания словаря с наполненными значениями

Общий вид генератора словарей:

" { ключ: значение for переменная in последовательность} "


a = { i: i ** 2 for i in range(1, 11) }

print(a)				 # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81, 10: 100}


"Без генератора этот код имел бы следующий вид"

a = {}

for i in range(1, 11):
    a[i] = i**2
    
print(a) 				# {1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81, 10: 100}



Внутри генератора словарей можно обходить любую коллекцию, поддерживающую итерацию. 
Для примера возьмём в качестве последовательности список, состоящий из строк:


a = {word:len(word) for word in ['hi', 'hello', 'www']}

print(a) 			# {'hi': 2, 'hello': 5, 'www': 3}




При помощи генератора можно обходить и уже существующие словари. 

"В словаре data сделаем так, чтобы заглавными были только первые буквы каждого слова, а значения преобразуем из строк в целые числа"


data = {
    'Джефф Безос': '177',
    'ИлоН МаСк': '126',
    'бернар АрнО': '150',
    'БиЛл ГеЙтС': '124',
}

new_data = {key.title(): int(value) for key, value in data.items()}

print(new_data)


{'Джефф Безос': 177, 'Илон Маск': 126, 'Бернар Арно': 150, 'Билл Гейтс': 124}



Без генератора мы должны были бы сделать следующим образом:

new_data = {}

for key, value in data.items():
    new_data[key.title()] = int(value)
    
print(new_data)


Возьмём для следующего примера список, хранящий данные о пользователе, в котором хранятся его id, имя и пароль:

users = [
    [0, 'Bob', 'password'],
    [1, 'code', 'python'],
    [2, 'Stack', 'overflow'],
    [3, 'username', '1234'],
    [51, 'qwerty', '1234']
]


В таком списке, выводя users[1] мы получим список: [1, 'code', 'python'], а выводя users[4] мы получим список [51, 'qwerty', '1234'].

"Но что, если нам надо обращаться не по индексу в списке, а по id пользователя?"
Для этого надо сделать следующий генератор:


from pprint import pprint

users = [
    [0, 'Bob', 'password'],
    [1, 'code', 'python'],
    [2, 'Stack', 'overflow'],
    [3, 'username', '1234'],
    [51, 'qwerty', '1234']
]

new_users = {user[0]: user for user in users}

pprint(new_users)
print('*'*15)
pprint(new_users[3])
pprint(new_users[51])



***************************************

Перед вами словарь user

Напишите программу для создания нового словаря, которая извлекает указанные ключи из приведенного ниже словаря.

Сами значения ключей, которые нужно извлечь, поступает на вход программе в виде одной строки разделенные пробелом


user = {
    "id": 4170,
    "uid": "5e941db5-9e0f-4f94-9fc5-734110c6be14",
    "password": "SyUpfo1ljm",
    "first_name": "Teresa",
    "last_name": "Wehner",
    "username": "teresa.wehner",
    "email": "teresa.wehner@email.com",
    "gender": "Non-binary",
    "phone_number": "+674 424.561.2776",
    "social_insurance_number": "637316241",
    "date_of_birth": "1993-08-17",
    "employment": {
        "title": "Central Hospitality Liaison",
        "key_skill": "Organisation"
    },
    "subscription": {
        "plan": "Essential",
        "status": "Idle",
        "payment_method": "Debit card",
        "term": "Annual"
    }
}

str = input().split()

new_users = { i: user[i] for i in str}

print(new_users)


~~

print({i:user[i]  for i in input().split()})

~~

print({key: user[key] for key in input().split()})

~~

print({i:user[i] for i in list(input().split())})

~~

result = {key: user.get(key) for key in (input().split())}

print(result)


*******************************************

В вашем распоряжении имеется вложенный список people, в котором хранятся имена и телефоны. 

Ваша задача создать словарь при помощи генератора словарей, в котором в качестве ключей будут храниться номера телефонов, а значениями будут имена владельцев. 

Обязательно сохраните этот словарь в переменной phone_book.


people = [
    ['Amy Smith', '694.322.8133x22426'],
    ['Brian Shaw', '593.662.5217x338'],
    ['Christian Sharp', '118.197.8810'],
    ['Sean Schmidt', '9722527521'],
    ['Thomas Long', '163.814.9938'],
    ['Joshua Willis', '+1-978-530-6971x601'],
    ['Ann Hoffman', '434.104.4302'],
    ['John Leonard', '(956)182-8435'],
    ['Daniel Ross', '870-365-8303x416'],
    ['Jacqueline Moon', '+1-757-865-4488x652'],
    ['Gregory Baker', '705-576-1122'],
    ['Michael Spencer', '(922)816-0599x7007'],
    ['Austin Vazquez', '399-813-8599'],
    ['Chad Delgado', '979.908.8506x886'],
    ['Jonathan Gilbert', '9577853541']
]

phone_book = {i[1]: i[0] for i in people}

#используя генератор словря мы в цикле перебераем список, в котором хранятся списки и в этих списках второе значение - ключ, а первое - значение

~~

phone_book = {phone: name for name, phone in people }

~~

phone_book = {people[i][1]: people[i][0] for i in range(len(people))}

~~

phone_book = {value:key for key, value in people}


~~

phone_book = { phone:name for (name, phone) in people }

~~

phone_book = {people[i][1]: people[i][0] for i in range(len(people))}



=========== 6.9 Вспомним вновь генераторы списков ===============


https://stepik.org/lesson/372102/step/1?unit=359656


" 	Генераторы списков | List comprehension | Вложенные генераторы 	"


Мы имеем список, элементами которого являются кортежи. 
У кортежей так же есть своя индексация. 
Теперь при помощи генератора списка будем доставать нужные нам значения:

a = [
    ("Sidorov", 1995),
    ("Lukov", 2002),
    ("Petrov", 1991),
    ("Gorbachev", 1984),
    ("Kostin", 2000),
    ("Isaev", 2005),
    ("Eliseev", 1999),
    ("Kozlov", 2004),
    ("Bukov", 1995),
    ("Gavrilov", 1980),
    ("Efremov", 2006),
]

print(a[4][0])

" surnames = [elem[0] for elem in a]  " 				# Получим только фамилии
" years = [elem[1] for elem in a] "  						# Получим только год рождения

print(surnames)

print('-' * 20)
print(years)


Но что, если нам нужно отфильтровать значения и взять только определенные данные. 
Тоже можем такое реализовать при помощи генератора списка. 


только те фамилии, которые начинаются с буквы E
только  тех людей, чей год рождения больше, чем 2000
только первые буквы с каждой фамилии, год рождения которых больше 2000


" name_start_e = [elem[0] for elem in a if elem[0].startswith("E")] "

print(name_start_e) 				# ['Eliseev', 'Efremov']


" more_2000 = [elem[0] for elem in a if elem[1] > 2000] "

print(more_2000) 				# ['Lukov', 'Isaev', 'Kozlov', 'Efremov']


"  first_letter = [elem[0][0] for elem in a if elem[1] > 2000]  "

print(first_letter)					# ['L', 'I', 'K', 'E']




***

a = {
    'Sidorov': {'age': 1995, 'hobby': 'soccer', 'car': 'BMW'},
    'Lukov': {'age': 2002, 'hobby': 'basketball', 'car': 'Opel'},
    'Petrov': {'age': 1991, 'hobby': 'chess', 'car': 'BMW'},
    'Gorbachev': {'age': 1984, 'hobby': 'tennis', 'car': 'BMW'},
    'Kostin': {'age': 2000, 'hobby': 'swimming', 'car': 'Audi'},
    'Isaev': {'age': 2005, 'hobby': 'music', 'car': 'BMW'},
    'Eliseev': {'age': 1999, 'hobby': 'chess', 'car': 'Audi'},
    'Kozlov': {'age': 2004, 'hobby': 'soccer', 'car': 'Opel'},
    'Bukov': {'age': 1995, 'hobby': 'basketball', 'car': 'Audi'},
}    


Рассмотрим один из его элементов: ключом является фамилия человека, а значением является словарь, состоящий из 3 ключей: возраст, хобби, автомобиль. 
Давайте получим какие-то данные при помощи генератора.
 

" keys = [elem for elem in a] "

  print(keys)
  
  ['Sidorov', 'Lukov', 'Petrov', 'Gorbachev', 'Kostin', 'Isaev', 'Eliseev', 'Kozlov', 'Bukov']
  

print('-'*30)

" values = [a[elem] for elem in a] "

  print(values)

[{'age': 1995, 'hobby': 'soccer', 'car': 'BMW'}, {'age': 2002, 'hobby': 'basketball', 'car': 'Opel'}, {'age': 1991, 'hobby': 'chess', 'car': 'BMW'}, {'age': 1984, 'hobby': 'tennis', 'car': 'BMW'}, {'age': 2000, 'hobby': 'swimming', 'car': 'Audi'}, {'age': 2005, 'hobby': 'music', 'car': 'BMW'}, {'age': 1999, 'hobby': 'chess', 'car': 'Audi'}, {'age': 2004, 'hobby': 'soccer', 'car': 'Opel'}, {'age': 1995, 'hobby': 'basketball', 'car': 'Audi'}]


***

" cars = [a[elem]['car'] for elem in a] "
print(cars)


print('-' * 30)

" hobbies = [a[elem]['hobby'] for elem in a] "
print(hobbies)


print('-' * 30)

" cars_lt_2000 = [a[elem]['car'] for elem in a if a[elem]['age'] < 2000] "
print(cars_lt_2000)


print('-' * 30)


" name_with_car = [(elem, a[elem]['car']) for elem in a if a[elem]['age'] < 2000] "

print(name_with_car)


print('-' * 30)


" less_2000_and_soccer = [(elem, a[elem]['car']) for elem in a if a[elem]['age'] < 2000 and a[elem]['hobby'] == 'soccer'] "
                        
print(less_2000_and_soccer)


***

Мы можем при помощи генератора списка сформировать два списка: 
в одном будут хранится только цифры, в другом - только буквы


s = 'gfdogjdf45i398gry74y543hgkgreiuYIUGd'

" str_digits = [i for i in s if i.isdigit()] "

print(str_digits)


print('-'*30)

" int_digits = [int(i) for i in str_digits if i.isdigit()] "

print(int_digits)

print('-'*30)


" letters = [i for i in s if i.isalpha()] "


print(letters)


*** напишем вложенный генератор и для заполнения используем случайные числа с помощью модуля рандом:


from random import randint

n = 5
m = 3

a = [[randint(1,6) for j in range(m)] for i in range(n)]

for i in a:
    print(i)



Принцип работы похож на тот, по которому работают вложенные циклы.
Сделаем квадратную таблицу и в список b будем вносить лишь элементы главной диагонали, а в список c только элементы со строки с индексом 2, а в список d только элементы столбца с индексом 3.



from random import randint

n = 5
m = 5
a = [[randint(1, 6) for j in range(m)] for i in range(n)]
for i in a:
    print(i)

b = [a[i][j] for i in range(n) for j in range(m) if i == j]
print('main diagon', b)

с = [a[2][j] for j in range(m)]
print('2 row', с)

d = [a[i][3] for i in range(n)]
print('3 column', d)



" как при помощи вложенных генераторов можно составить таблицу умножения."


n = 5
m = 5

a = [[i * j for j in range(m)] for i in range(n)]

for i in a:
    print(i)




n = 5
m = 5

a = [[i * j for j in range(1, m + 1)] for i in range(1, n + 1)]
for i in a:
    print(i)



" Также вы можете спокойно обходить элементы матрицы внутри генератора списка по значениям, для этого достаточно во внутреннем цикле обращаться к итерируемой переменной внешнего цикла "

n = 3
m = 4

matrix = [[randint(1, 10) for j in range(m)] for i in range(n)]
for current_row in matrix:
    print(current_row)

print('-' * 30)

squares = [num ** 2 for row in matrix for num in row]
print(squares)




*************************************

Декартово произведение

Декартово произведение двух множеств — множество, элементами которого являются все возможные упорядоченные пары элементов исходных множеств. Под множествами в этой задачи мы будем считать списки, один из них будет содержать цвета маек, а другой размеры одежды. 

Если объяснять более простым языком, то  декартово произведение это когда вы каждый элемент из одного множества группируете с каждый элементом другого множества. 



colors = ['White', 'Blue', 'Yellow', 'Purple', 'Black', 'Green']
sizes = ['S', 'M', 'L', 'XL', 'XLL']

# используя генератор списка создаем новый список. 
# res = list()
# for i in colors:
#     for j in sizes:
#         res.append((i,j))    

res = [(i, j) for i in colors for j in sizes]

# выводим получившийся список
print(res)

~~

from itertools import product as decart

colors = ['White', 'Blue', 'Yellow', 'Purple', 'Black', 'Green']
sizes = ['S', 'M', 'L', 'XL', 'XLL']

print(list(decart(colors, sizes)))


~~

colors = ['White', 'Blue', 'Yellow', 'Purple', 'Black', 'Green']
sizes = ['S', 'M', 'L', 'XL', 'XLL']

print(list(__import__('itertools').product(colors, sizes)))


~~

print(list((i, j) for i in colors for j in sizes))

~~

from itertools import product

colors = ['White', 'Blue', 'Yellow', 'Purple', 'Black', 'Green']
sizes = ['S', 'M', 'L', 'XL', 'XLL']

print([*product(colors, sizes)])

~~

print([(i, j) for i in ['White', 'Blue', 'Yellow', 'Purple', 'Black', 'Green'] for j in ['S', 'M', 'L', 'XL', 'XLL']])

~~

rez = []

for i in colors:
    for j in sizes:
        rez.append(tuple([i,j]))

print(rez)


rez = []
for i in range(len(colors)):
    for j in range(len(sizes)):
        rez.append(tuple([colors[i],sizes[j]]))

print(rez)


" ******************* ************************ ***************** "

В вашем распоряжении есть двумерный список vector. 

Ваша задача при помощи генератора-списка сделать на основании vector линейный(одномерный ) список и вывести его


vector = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]]


# используя генератор списка создаем новый список. 
Первый список переберет весь список и каждую итерацию i равна списку, затем вторым циклом мы проходимся по i и добавляем из него числа в наш список

a = [j for i in vector for j in i] 

print(a)


~~

print(sum([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]], []))

~~

print([vector[i][j] for i in range(len(vector)) for j in range(len(vector[i]))])


~~  how to flatten a 2D list to 1D 

list_of_lists = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(sum(list_of_lists, []))  # [1,2,3,4,5,6,7,8,9]

lst = []
for sublist in list_of_lists:
    for item in sublist:
        lst.append(item)

print(lst)  # [1,2,3,4,5,6,7,8,9]


~~

vector = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]]

b=len(vector)
a = [vector[i][j] for i in range(b) for j in range(len(vector[i]))]
print(a)


~~

vector = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]]

v = [vector[i][j] for i in range(len(vector)) for j in range(len(vector[i]))]
# v = []  или так !!!!!!
# for i in range(len(vector)):
#     for j in range(len(vector[i])):
#         v.append(vector[i][j])
# v = [i for j in vector for i in j] или так !!!!!!!!!
print(v)

~~

a=[]

[a.extend(i) for i in vector]
print(a)


============== 6.10 Знакомство с множествами. Тип данных set ===========

https://stepik.org/lesson/772400/step/1?unit=774833


под множеством понимается  набор, совокупность каких-либо объектов, называемых элементами этого множества. Например, рассмотрим кириллицу, алфавит этого языка состоит из 33 букв. 

При помощи этих букв образованы все слова русского языка. И тогда мы можем сказать, что множество русского языка состоит из 33 элементов: букв от А до Я


Множеством английского языка будет 26 элементов: буквы от A до Z

Количество элементов в множестве арабских цифр равно 10: это цифры от 0 до 9. Именно при помощи этих цифр образованы все числа




====== Множество в python ========

"Множество (тип данныхset) – это неупорядоченная коллекция уникальных элементов. Здесь стоит подчеркнуть слово уникальных, потому что тип данных set не допустит, чтобы в одной коллекции хранились повторяющиеся элементы. "


====== Способы создания множества =====


1) При помощи фигурных скобок:

a = {1, 2, 3}
print(a)
print(type(a))

b = {1, 2, 1, 2, 3, 1, 1, 4}
print(b)
print(type(b))

"Обращаю еще раз ваше внимание на то, что в полученных множествах находятся уникальные элементы в одном экземпляре и нету ни одного повторяющего значения."

"Также важно отметить, что множество является неупорядоченной коллекцией, то есть в предыдущем случае мы могли бы получить что-то из следующего: {1, 4, 3, 2} , {4, 3, 2, 1} или {4, 2, 1, 3} и т.д."


2) При помощи функции set() мы можем преобразовать другую коллекцию (список, строку и т.д.) в множество

a = set('abcdeabc')
b = set([1, 2, 3, 2, 3, 1, 3])
c = set(range(5))



		===== Создание пустого множества ======
		
a = set()
print(a)
print(type(a))

"Чтобы создать пустое множество необходимо воспользоваться функцией set() без указания аргументов. Стоит отметить, что нельзя создать множество с помощью пустых фигурных скобок {}, т.к. при помощи пустых фигурных скобок создается словарь."


"Словари и множества оба записываются в фигурных скобках, это создает небольшую путаницу. Не забывайте, что словари содержат пары ключ-значения, которые всегда записываются через двоеточие. Именно по наличию знака : в выводе объекта можно понять, что перед вами словарь. Также вы всегда можете проверить тип объекта."


		===== Ограничение на элементы множества =====
		
"Множество может состоять только из неизменяемых объектов. К примеру, множество можно сделать из списка чисел, но вот из вложенного списка уже нельзя, поскольку элементами такого списка являются списки, которые сами по себе являются изменяемыми объектами."		
		
a = [1, 2, 3, 4, 3, 2, 3, 1, 3, 4, 2, 2, 2]
a = list(set(a))



b = [[1, 2, 3, 4], 
     [3, 2, 3, 1], 
     [3, 4, 2, 2]]
b = set(b)
print(b)					=> TypeError: unhashable type: 'list'
		
		
" При попытки создать множество, содержащее изменяемый  объектом, возникнет ошибка "

TypeError: unhashable type



			" К неизменяемым объектам, напоминаю, относятся "

1) строки

2) числа int и float

3) кортежи

4) frozenset 

5) Все эти значения могут являться элементами множества


***************

Как создать пустое множество и сохранить его в переменной d?  =>  d = set()

print(my_set := set())

my_set=set()

**************

Какое количество элементов будет содержать множество, хранящееся в переменной my_set?

my_set = set([1, 2, 2, 2, 2, 1, 1, 2, 2, 1, 2])  => два (2)


~~

Множество => не может содержать повторяющиеся данные

~~

Элементами множества могут быть => только неизменяемые объекты



			===== Операции над множествами =====
			
Множество, представляет собой неупорядоченную коллекцию элементов. Раз это коллекция, то к ней можно применять такие стандартные операции как нахождение длины, проверки вхождения элемента, итерирование и т.д. 



*** "При помощи функции len() можем найти количество элементов множества"

a = {1, 2, 3}
print(f'Длина a = {len(a)}')

b = set()
print(f'Длина b = {len(b)}')

c = set([1, 1, 2, 2, 1, 2, 1])
print(f'Длина c = {len(c)}')




*** "Проверка на нахождение"

*** Оператор in позволяет проверить имеется ли элемент в множестве или нет. Если данный элемент присутствует, то результат будет  True, в обратном случае – False.


a = {1, 2, 3}

print(2 in a)
print(5 in a)
print(4 not in a)
print(1 not in a)


*** "Поиск максимума и минимума в множестве"

Функции min(), max() позволяют найти минимальный и максимальный элемент множества

a = {1, 2, 3}
print(min(a), max(a))

b = set([11, 19, 22, 2, 13, 22, 10])
print(min(b), max(b))


"Функции min(), max() можно использовать только если множество состоит из однотипных элементов, которые можно сравнить между собой (целиком из чисел или целиком из строк)."

 Если бы наше множество было бы таким:

a = {1, 2, 'hi', 4, 5}
то получили бы ошибку TypeError: '>' not supported between instances of 'str' and 'int'.



*** "Суммирование элементов множества"

Просуммировать элементы множества возможно, если оно состоит исключительно из чисел:

a = {2, 4, 5, 7, 8, 9}
print(sum(a))

Если в множестве будут присутствовать не числа, то получим ошибку TypeError: unsupported operand type(s) for +



*** "Сортировка множества" 


При помощи функции sorted() можно отсортировать множество, если в нем содержатся однородные элементы.

"Результат работы функции sorted() всегда является список "

my_set = {8, 4, 7, 5, 2, 3, 6}

sorted_list = sorted(my_set)
print(sorted_list)


my_string_set = {'profit', 'fare', 'thesis', 
                 'architecture', 'insurance',
                 'hero', 'shrink', 'north', 
                 'drill', 'toast'}
print(sorted(my_string_set))


Если внутри вашего множества будут хранится элементы, не поддерживающие операцию сравнения между собой (например числа и строки), получите ошибку TypeError: '<' not supported between instances of 'str' and 'int'




		***** "Операции, которые нельзя выполнять над множествами" *****

1) Индексация

К элементам множества нельзя обращаться по индексу, это приведет к ошибке TypeError: 'set' object is not subscriptable




2) Функция reversed

Функцию reversed() нельзя использовать для множества, так как множество представляет собой неупорядоченную коллекцию. При попытке вызывать функцию reversed()  вы получите ошибку TypeError: 'set' object is not reversible


******************

Что произойдет после выполнения данного кода?

my_set = {8, 4, 7, 3, 6}
print(sorted(my_set))				=> [3, 4, 6, 7, 8]


~~

Что произойдет после выполнения данного кода?

my_set = {8, 4, 7, 3, 6}
print(reversed(my_set))			=> ошибка TypeError: 'set' object is not reversible


************************************

Перед вами располагается список my_list. Ваша задача в переменную my_set сохранить множество уникальных элементов, хранящихся в списке my_list. И в качестве ответа необходимо вывести среднее арифметическое всех элементов найденного множества my_set.

my_list = [56, 59, 53, 75, 62, 61, 75, 65, 59, 62, 64, 53,
           54, 62, 69, 53, 55, 62, 54, 66, 55, 57, 58, 75,
           72, 55, 51, 56, 71, 66, 57, 56, 59, 73, 68, 57,
           50, 54, 62, 68, 59, 64, 59, 59, 71, 68, 57, 54, 53, 72]
           
my_set = set(my_list)             # переобразуем список во множество
print(sum(my_set) / len(my_set))  

# выводим среднее арифметическое этого множества(сумма разделить на количество). Сумму находим функцией sum(), а количество(длину) функцией - len()


~~

print(sum(my_set := set(my_list)) / len(my_set))

~~

from statistics import mean

my_list = [56, 59, 53, 75, 62, 61, 75, 65, 59, 62, 64, 53,
           54, 62, 69, 53, 55, 62, 54, 66, 55, 57, 58, 75,
           72, 55, 51, 56, 71, 66, 57, 56, 59, 73, 68, 57,
           50, 54, 62, 68, 59, 64, 59, 59, 71, 68, 57, 54, 53, 72]

my_set = mean(set(my_list))

print(my_set)

~~

my_set = set(my_list)
print(sum(my_set)/len(set(my_list)))

~~

print(my_set := sum(set(my_list))/len(set(my_list)))




***********************************

	Девушка или Юноша
	
Если пользователь оказался женского пола по методу нашего героя, выведите «CHAT WITH HER!» (без кавычек), иначе, выведите «IGNORE HIM!» (без кавычек).


str = input()
login = set(str)

if len(login) % 2 == 0:
    print("CHAT WITH HER!")
else:
    print("IGNORE HIM!")


~~

print(('CHAT WITH HER!', 'IGNORE HIM!')[len(set(input())) % 2])

~~

print("IGNORE HIM!" if len(set(input())) % 2 else "CHAT WITH HER!")

~~

print('IGNORE HIM!'*(len(set(input()))%2) or 'CHAT WITH HER!')

~~

print("CHAT WITH HER!" if not len(set(input())) % 2 else "IGNORE HIM!")

~~

name = set([i for i in input()])
print('IGNORE HIM!' if len(name) % 2 != 0 else 'CHAT WITH HER!')


**************************************

 Не смешите мои подковы
 
 
color = input().split()       # получаем строку с цветами(числами) и разбиваем на список
color_set = set(color)     # преобразовываем список во множетво

# выводим сколько подков ему не хватает другого цвета(всего надо 4, мы узнаем длину множества с его разными подковами и 4 минусуем с длиной(количеством))

print(4 - len(color_set))


~~

horseshoes = len(set(input().split()))
print(4 - horseshoes)

~~

lst = list(input().split())  # ввод строки, сплитим, преобразуем в список

ls_set = set(lst)            # преобразуем список в множество

print(len(lst)-len(ls_set))  # вывод разницы списка и множества

# решение в 1 строку: вывод разницы длины списка и множества:
# print (4 - len(set(input().split())))


~~

print(4 - len(set(input().split())))


~~

print(4-len(set(map(int,input().split()))))


************************************************

				Панграмма
				
Вам дана строка, состоящая из маленьких и больших латинских букв. Проверьте, является ли эта строка панграммой. Считается, что строка содержит букву латинского алфавита, если эта буква встречается в верхнем или нижнем регистре.				


text = input().lower()   # получаем строку и опускаем в нижний регистр
text_set = set(text)     # преобразуем строку во множество, в котором будут храниться буквы использованные в строке
if len(text_set) == 26:  # проверяем если длина множества с использованными буквами равна длине алфавита, то выводим YES, иначе NO
    print('YES')
else:
    print('NO')


~~

print('YES' if len(set(input().lower())) == 26 else 'NO')


~~

print(('NO', 'YES')[len(set(input().lower())) == 26])

~~

abc = 'abcdefghijklmnopqrstuvwxyz'

print(('NO','YES')[set(input().lower()) == set(abc)])

~~


***************************************

			Красивый год

Выведите единственное целое число — минимальный номер года, который строго больше year, в котором все цифры различны. Гарантируется, что ответ существует и является четырехзначным числом, то есть не выходит за рамки значения 9999.


year = int(input())     			# получаем год, после которого надо найти уникальный год


while True:             # цикл выполняется пока не закончим его сами
    year += 1           # для того чтобы перейти к следующему году для проверки к году прибавляем 1
    
    
    # преобразуем для начала число в строку, чтобы затем конвертируем воо множество, 
    и если в нем хранится 4 цифры, то год уникален,

    if len(set(str(year))) == 4: 
            print(year)     # выводим уникальный год
        	break           # заканчиваем цикл, чтобы не зациклить и он не искал следующий год


~~

y = int(input()) + 1

while len(set(str(y))) != 4: 
	y += 1

print(y) 



year = int(input()) + 1

while len(set(str(year))) < 4:
    year += 1
print(year)


~~

for i in range(int(input()) + 1, 10_000):
    if len(set(str(i))) == 4:
        print(i)
        break
        
~~

print([i for i in range(int(input())+1,10000)if len(set(str(i)))==4][0])

~~

a = [i for i in range(int(input()) + 1, 10000)]

for i in range(len(a)):
    if len(set([i for i in str(a[i])])) == 4:
        break
        
print(a[i])


***************************************

			Антон и буквы
			
			Входные данные
В первой и единственной строке задано описание множества букв. Длина строки не превышает 1000. Гарантируется, что строка начинается с открывающейся фигурной скобки, а заканчивается закрывающейся. Между ними через запятую перечислены маленькие латинские буквы. После каждой запятой следует пробел.

	Выходные данные
Выведите единственное число — количество различных букв в множестве Антона.	
		
			
letters = input()     # получаем строкой множество

# генератором во множество добавляем только буквы(мы это проверяяем с помощью метода .isalpha()

a = { i for i in letters if i.isalpha() } 

print(len(a))         # выводим длину полученного множества


~~

s = [i for i in input() if i.isalpha()]
print(len(set(s)))

~~

print(len(set(input()) - set('{ },')))


~~

print(sum(i.isalpha() for i in set(input())))

~~

s = input()

res = []

for i in s:
    if i.isalpha():
        res.append(i)
        
print(len(set(res)))

~~

s = input()[1:-1]
print(len(set(s.split(', '))) if s else 0)

~~

a = list(input())

b = []

count = 0

for i in a:
    if i.isalpha():
        b.append(i)   
          
print(len(set(b)))



================ 6.11 Операции с множествами ================

https://stepik.org/lesson/779028/step/1?unit=781552


			*** "Специфические операции над множествами " ***

в математике над множествами можно делать достаточно интересные операции, такие как:

1. объединение
2. пересечение
3. разность множеств
4. симметрическая разность и т.д.



			*** "Пересечение множеств " ***
			

Пересечение ( от английского intersection) множеств позволяет определить какие элементы присутствуют одновременно в указанных множествах. 
В математике пересечение множеств A и В обозначается так A∩B


" Результатом пересечения множеств будет является другое множество "

В реальной жизни при помощи пересечения вы можете определить список общих друзей в социальной сети с другим пользователем. 

За кружочек слева А мы можем обозначить множества ваших друзей, за кружок справа B - множество друзей другого пользователя.

Тогда общая область этих кругов, область где они пересекаются, так раз и будет содержать множество общих друзей. Вполне возможно, что пересечение множеств будет пустым. 

Такое произойдет в случае отсутствия общих друзей.


"Если два множества не имеют общих элементов, то говорят, что эти множества не пересекаются. Или другими словами, пересечение этих множеств является пустым множеством."


"Для того, чтобы найти пересечение двух множеств, в python используется оператор < & >. Результатом этого оператора будет новое множество. Можно искать пересечение двух и более множеств"


my_friend = {'Bill', 'Ash', 'Pikachu', 'Jim'}
jack_friends = {'Bill', 'Kir', 'Pikachu'}

" intersections_me_jack = my_friend & jack_friends "
print('Мои общие друзья с Джеком', intersections_me_jack)

terry_friends = {'Zara', 'Pit', 'Pikachu'}

" intersections_me_jack_terry = my_friend & jack_friends & terry_friends "

print('Мои общие друзья с Джеком и Терри', intersections_me_jack_terry)

jim_friends = {'Zara', 'Charmander'}

" intersections_me_jim = my_friend & jim_friends "

print('Мои общие друзья с Джимом', intersections_me_jim)


*****

Каков будет результат операции A∩B?

one = {'a', 'b', 'c', 'd'}
two = {'c', 'd', 'e'}

intersection = one & two
print(intersection) 			=> {'d', 'c'}

***********************************

Перед вами располагается два множества  set_a и set_b

Ваша задача вывести на экран количество элементов, которое содержится в результате пересечения множеств set_a и set_b


set_a = {31, 37, 39, 41, 47, 58, 60, 62, 70, 75,
         76, 77, 78, 79, 80, 81, 85, 86, 88, 90, 93, 96, 98, 99}

set_b = {0, 1, 8, 16, 17, 18, 22, 24, 29, 31,
         33, 34, 36, 42, 46, 47, 51, 53, 62, 64, 65, 66, 67}

intersec = set_a & set_b

print(len(intersec))


~~

print(len(set_a & set_b))

~~

print(len(set_a.intersection(set_b)))



								******************************************************

		*** " Объединение множеств " ***

Объединение ( от английского union) двух или более множеств объединит в себе все элементы, принадлежащие любому из указанных множеств. 

В математике объединение множеств A и В обозначается  A∪B

"Результатом объединения множеств будет является другое множество"

Для того, чтобы найти объединение двух множеств, в python используется оператор < |  >. 
Результатом этого оператора будет новое множество. 
Можно искать Объединение двух и более множеств


my_friend = {'Bill', 'Ash', 'Jim'}
jack_friends = {'Bill', 'Kir'}

" union_me_jack = my_friend | jack_friends "
print('Все наши друзья с Джеком', union_me_jack)

terry_friends = {'Zara', 'Pit'}
" union_me_jack_terry = my_friend | jack_friends | terry_friends "
print('Все наши друзья с Джеком и Терри', union_me_jack_terry)

jim_friends = {'Bill', 'Charmander'}
" union_me_jim = my_friend | jim_friends "
print('Все наши друзья с Джимом', union_me_jim)




one = {'a', 'b', 'c', 'd'}
two = {'c', 'd', 'e'}

union = one | two
print(union)				=> {'c', 'b', 'e', 'd', 'a'}


*******************************

Перед вами располагается два множества  set_a и set_b

Ваша задача вывести на экран количество элементов, которое содержится в результате объединения множеств set_a и set_b

set_a = {31, 37, 39, 41, 47, 58, 60, 62, 70, 75,
         76, 77, 78, 79, 80, 81, 85, 86, 88, 90, 93, 96, 98, 99}

set_b = {0, 1, 8, 16, 17, 18, 22, 24, 29, 31,
         33, 34, 36, 42, 46, 47, 51, 53, 62, 64, 65, 66, 67}

union = len(set_a | set_b)
print(union)


~~

"print( len(set_a.union(set_b)) )"

~~

" print(len(set_a|set_b)) "




		******************** " Разность множеств " *****************

" Разность( от английского difference) двух множеств это операция, позволяющая получить новое множество, в которое входят все элементы первого множества, не входящие во второе множество."


" Для того, чтобы найти разность двух множеств, в python используется оператор < - > "
Результатом этого оператора будет новое множество. 
Можно искать разность двух и более множеств



my_friend = {'Bill', 'Ash', 'Jim'}
jack_friends = {'Bill', 'Kir'}

" me_difference_jack = my_friend - jack_friends  "
print('Мои друзья минус друзья Джека', me_difference_jack)

" jack_difference_me = jack_friends - my_friend "
print('Друзья Джека минус мои друзья', jack_difference_me)



Каков будет результат операции  B−A ?

one = {'a', 'b', 'c', 'd'}
two = {'c', 'd', 'e'}

difference = two - one
print(difference)					=> {e}


*******************************

Перед вами располагается два множества  set_a и set_b

Ваша задача вывести на экран два числа в отдельных строках:

сперва количество элементов, которое содержится в результате операции set_a - set_b 
затем количество элементов, которое содержится в результате операции set_b - set_a 


set_a = {31, 37, 39, 41, 47, 58, 60, 62, 70, 75,
         76, 77, 78, 79, 80, 81, 85, 86, 88, 90, 93, 96, 98, 99}

set_b = {0, 1, 8, 16, 17, 18, 22, 24, 29, 31,
         33, 34, 36, 42, 46, 47, 51, 53, 62, 64, 65, 66, 67}

first = len(set_a - set_b)
second = len(set_b - set_a)

print(first, second, sep='\n')

~~

"  print( len(set_a.difference(set_b)), len(set_b.difference(set_a)), sep='\n')  "

~~

" ~~ "  print(f"{len(set_a.difference(set_b))}\n{len(set_b.difference(set_a))}")  

~~

print(*map(len, (set_a - set_b, set_b - set_a)), sep='\n')

~~

print(len(set_a - set_b))

print(len(set_b.difference(set_a)))

~~



		******************** " Симметрическая разность множеств " *****************

Симметрическая разность ( от английского symmetric difference) двух множеств – это операция,  позволяющая получить новое множество, в которое включены все элементы двух множеств, не принадлежащие одновременно обоим исходным множествам. 



" Для того, чтобы найти симметрическую разность двух множеств, в python используется оператор < ^ > "

Результатом этого оператора будет новое множество. 

Можно искать симметрическую разность двух и более множеств


my_friend = {'Bill', 'Ash', 'Jim'}
jack_friends = {'Bill', 'Kir'}

" symm_diff_me_jack = my_friend ^ jack_friends  "
print('Симметрическая разность с Джеком', symm_diff_me_jack)

terry_friends = {'Zara', 'Pit'}
" symm_diff_me_terry = my_friend ^ terry_friends "
print('Симметрическая разность с Терри', symm_diff_me_terry)


****

Давайте проверим как вы усвоили symmetric difference. Имеется два множества: A={a,b,c,d} и B={c,d,e}.



one = {'a', 'b', 'c', 'd'}
two = {'c', 'd', 'e'}

symm = one ^ two
print(symm)					=> {'a', 'e', 'b'}


**********************************************

Перед вами располагается два множества  set_a и set_b

Ваша задача вывести на экран количество элементов, которое содержится в результате операции симметрическая разность множеств set_a и set_b

set_a = {31, 37, 39, 41, 47, 58, 60, 62, 70, 75,
         76, 77, 78, 79, 80, 81, 85, 86, 88, 90, 93, 96, 98, 99}

set_b = {0, 1, 8, 16, 17, 18, 22, 24, 29, 31,
         33, 34, 36, 42, 46, 47, 51, 53, 62, 64, 65, 66, 67}

print(len(set_a ^ set_b))


~~

" print(len(set_a.symmetric_difference(set_b)))  "





****************			*** "Обход элементов множества " ***

Поскольку множество является последовательностью, то мы можем итерироваться по ней, или, другими словами, обходить его элементы при помощи цикла for:


a = {1, 'hi', 2, 1, False, 6, 'the', True}

for item in a:
    print(item)
    
    
    В данном случае мы обошли элементы множества по значениям. Но поскольку множество является неупорядоченной коллекцией, то вариант обхода по индексам нам не доступен



**************************************

words = ['mention', 'soup', 'pneumonia', 'tradition', 'concert', 'tease', 'generation',
         'winter', 'national', 'jacket', 'winter', 'wrestle', 'proposal', 'error', 
         'pneumonia', 'concert', 'value', 'value', 'disclose', 'glasses', 'tank',
         'national', 'soup', 'feel', 'few', 'concert', 'wrestle', 'proposal', 'soup',
         'sail', 'brown', 'service', 'proposal', 'winter', 'jacket', 'mention', 'tradition',
         'value', 'feel', 'bear', 'few', 'value', 'winter', 'proposal', 'government', 
         'control', 'value', 'few', 'generation', 'service', 'national',
         'tradition', 'government', 'mention', 'proposal']
         


# с помощью генератора создаем множество со строками которых длина больше 6
         
set_words = {i for i in words if len(i) > 6}   

print(len(set_words))                          


~~

print(len([i for i in set(words) if len(i)>6]))

~~

print(sum([len(i) > 6 for i in set(words)]))

~~

print(len({i for i in set(words) if len(i) > 6}))

~~

print(sum(1 for word in set(words) if len(word) > 6))

~~


****************			*** "Сравнение множеств " ***

Проверка на равенство

два множества называются равными или эквивалентными, если они состоят из одних и тех же элементов и имеют одинаковое количество элементов. Как следует из определения множества, порядок этих элементов не важен. Для проверки множеств на равенство используется уже знакомый вам оператор ==


a = {1, 2, 3}
b = {3, 1, 2}
print(a == b)
print(a != b)

print(a == {1, 2})

**************************************


Вашей программе будут поступать на вход N списков, содержащих целые числа

Для каждого введенного списка определите, сколько в нем встречается различных чисел.


num = int(input())             # вводим число - количество введенных далее списков

for i in range(num):           # циклом получаем списки
    a = set(input().split())   # получили строки(списки) далее разбиваем на списки и конвертируем во множество
    print(len(a))              # выводим длину множества с уникальными символами из введенной строки(списка)


~~

print(*[len(set(input().split()))for i in range(int(input()))], sep='\n')       

~~

for i in range(int(input())):
    print(len(set(input().split())))
    
~~

print(*[len(set(map(int, input().split()))) for _ in range(int(input()))], sep='\n')

~~

for _ in range(int(input())):
    new_set = (set(map(int, input().split())))   
    print(len(new_set))


~~

n = int(input())

for _ in range(n):
    print(len(set(int(x) for x in input().split())))
    
    
    
    
    ================ 6.13 Неизменяемое множество frozenset ================
    
    https://stepik.org/lesson/843175/step/1?unit=846877
    
    
    
    				*** " Тип данных frozenset " ***
    				
Последний встроенный тип, который мы с вами разберем, это frozenset. 
С английского frozenset можно дословно перевести как замороженное множество.
 
"Слово замороженное подчеркивает фиксированность или неизменяемость элементов множества, и поэтому frozenset мы будем называть с вами неизменяемым множеством."
    
    

 "frozenset представляет собой такое же множество как и тип данных set , но с единственным и главным отличием - frozenset является неизменяемым объектом "


" Чтобы создать пустое неизменяемое множество необходимо воспользоваться функцией frozenset() , не передав в нее ничего. Либо передав в функцию пустую последовательность: пустой словарь, пустой список, пустой кортеж и т.д. "    
    
    
    							" Создание пустого неизменяемого множества "
    							
    			
froz = frozenset()
print(froz)

empty = frozenset([])
print(empty)

print(frozenset(''))
print(frozenset({}))
    
    
    						"  Создание frozenset на основании другой коллекции "
    
    
Мы можем создать frozenset на основании любой другой итерируемой коллекции, а именно  на основании:

1. строки
2. списка
3. кортежа
4. множества
5. словаря


" fr_abra = frozenset('abracadabra') "
print(fr_abra)

" fr_nums = frozenset([2, 1, 2, 4, 5, 2, 1]) "
print(fr_nums)

lang = {'eng':'Английский', 'ru':'Русский'}

" print(frozenset(lang)) "


my_set = {1, 2, 2, 3}
" print(frozenset(my_set)) "
    
    
*********************

Создайте пустой объект frozenset и сохраните его в переменную my_frozen, затем выведите на экран эту переменную

my_frozen = frozenset()
print(my_frozen)

~~

print(my_frozen := frozenset())

~~

Объект frozenset относится к =>  неизменяемым объектам

~~

Что произойдет после выполнения данного кода?

my_frozen = frozenset([8, 4, 7, 3, 6])
print(my_frozen[3])
=> TypeError: 'frozenset' object is not subscriptable



						***** "  Операции над frozenset " ******

1. При помощи функции len() можем найти количество элементов неизменяемого множества

2. Оператор in позволяет проверить имеется ли элемент во frozenset или нет. Если данный элемент присутствует, то результат будет  True, в обратном случае – False.

3. Функции min(), max() позволяют найти минимальный и максимальный элемент неизменяемого множества, если там хранятся элементы одного типа

4. Просуммировать элементы frozenset(если оно состоит исключительно из чисел)
Если во frozenset будут присутствовать не числа, то получим ошибку TypeError: unsupported operand type(s) for +


5. При помощи функции sorted() можно отсортировать frozenset, если в нем содержатся однородные элементы. Результат работы функции sorted() всегда является список


*********************

			Притягиваем удачу
			
В переменную my_frozen, сохраните объект frozenset , содержащий 77 элементов

Сами элементы это последовательность из 77-ми следующих чисел: 7, 77, 777, 7777, 77777, 777777, ..... 

В конце этой последовательности стоит число из 77-ми цифр 7, на предпоследнем месте - число из 76-ти цифр 7

Выводить ничего не нужно, только создать переменную my_frozen и правильно ее заполнить


# с помощью генератора создаем список с числами и преобразуем в неизменяемое множество

my_frozen = frozenset( [int('7' * (i + 1)) for i in range(77) ] )     

    
~~

c = range(1, 78)

d = []

for i in c:
    d.append('7' * i)
    
e = map(int, d)

##print(e)

f = sorted(e, reverse=True)
my_frozen = frozenset(f)

~~
my_frozen = frozenset((10 ** i - 1) // 9 * 7 for i in range(1, 78))

~~

n = 7

arr = [7]

for i in range(76):
    n = n * 10 + 7
    arr.append(n)
    
my_frozen = frozenset(arr)

~~

my_frozen1 = []

i = 1

while i <=77:
    my_frozen1.append(int('7'*i))
    i+=1
    
my_frozen = frozenset(my_frozen1)

 
~~

# ёлочка из семёрок

for i in range(1, 78):
    print(' ' * (78 - i),  '7' * (i * 2 - 1), ' ' * (78 - i))
    
    
~~

my_frozen = frozenset(int(i * '7') for i in range(1, 78))  
  
~~

my_frozen = []

for i in range(1, 78):
    my_frozen.append('7' * i)
    
result = list(map(int, my_frozen))

my_frozen = frozenset(result)

  
~~

frs = set()

for i in range(1, 10*7+8):
    frs.add(int('7' * i))
    
my_frozen = frozenset(frs)  
    
    
~~

s = [7]
i = '7'
while len(i) < 77:
    i += '7'
    s.append(int(i))
    
my_frozen = frozenset(s)  

~~

my_frozen = []

n = '7'

while len(n) != 78:
    my_frozen.append(n)
    n+='7'
    
my_frozen = frozenset(map(int, my_frozen))
    
    
    
    
 			***** " Методы frozenset " *****
    
 1. Метод .copy() выполняет поверхностное копирование элементов оригинального frozenset .   
    
 2. Метод .difference() позволяет выполнить операцию «разность множеств». 
 Результатом вызова метода .difference() будет новое неизменяемое множество куда войдут только элементы из операции разности множеств. Старые объекты никак не изменятся в процессе работы этого метода 
    
    
 3. Метод .union() позволяет выполнить операцию объединения. 
 Результатом вызова метода .union() будет новое неизменяемое множество, или, другими словами, новый объект frozenset


4. Метод .intersection() позволяет выполнить операцию пересечения. Результатом вызова метода .intersection() будет новое неизменяемое множество, или, другими словами, новый объект frozenset

    
5. Метод .symmetric_difference()  позволяет выполнить операцию «симметрическая разность». Результатом вызова метода .symmetric_difference() будет новое неизменяемое множество куда войдут только элементы из операции разности множеств. Старые объекты никак не изменятся в процессе работы этого метода  
    
    
 
 ~~
 
 person = {"name": "Jack", "age": 21, "Country": "India"}

frozen_dict = frozenset(person)
print(f'{frozen_dict=}')

a = frozen_dict.copy()

print(f'{a=}')

~~

frozen1 = frozenset([1, 2, 3, 4])

frozen2 = frozenset([3, 4, 5, 6])

frozen_diff = frozen1.difference(frozen2)

print(f'Разнцица между {frozen1} and {frozen2} = {frozen_diff}')

print(f'Разнцица между {frozen2} and {frozen1} = '
      f'{frozen2.difference(frozen1)}')


~~

frozen1 = frozenset([1, 2, 3, 4])

frozen2 = frozenset([3, 4, 5, 6])

frozen_union = frozen1.union(frozen2)

print(f'Объединение {frozen1} и {frozen2}={frozen_union}')


~~

frozen1 = frozenset([1, 2, 3, 4])

frozen2 = frozenset([3, 4, 5, 6])

frozen_intersection = frozen1.intersection(frozen2)

print(f'Пересечение {frozen1} и {frozen2}={frozen_intersection}')


~~

frozen1 = frozenset([1, 2, 3, 4])

frozen2 = frozenset([3, 4, 5, 6])

frozen_symm_diff = frozen1.symmetric_difference(frozen2)

print(f'Симм. разница {frozen1} и {frozen2}={frozen_symm_diff}')



=========			*** "Использование frozenset в словаре" ***

    
"frozenset в качестве ключа =>" Так как объект frozenset является неизменяемым, его можно использовать в качестве ключа в словаре. Обычные множества set не могли быть использованы в качестве ключа.

Объект frozenset хранит свои элементы без учета порядка и с удалением повторяющихся элементов, поэтому два набора, построенные в разном порядке, будут эквивалентными ключами в словаре — они одинаковы.

frozenset([1,2,2,3,3]) == frozenset([3,2,1,1,1]) 		=> True


    
 " frozenset в качестве значения словаря => "  frozenset как и любой другой объект можно спокойно использовать в качестве значения ключа. Словарь не накладывает на значения каких-либо ограничений.
    
a = frozenset([1, 1, 1, 1, 2, 3])
b = frozenset([3, 3, 3, 3, 4, 5])
frozen = {a: 1, 'name': b, b: a}
print(frozen)
    
    
    
    
 ===================== 6.14 Функция enumerate =================
 
 https://stepik.org/lesson/766214/step/1?unit=768547
 
 
 "Функция enumerate помогает обойти итерируемые коллекции с возможностью одновременно получать индекс элемента и его значение."

"Функция enumerate возвращает итератор, который можно легко преобразовать например к списку."




a = [ 10, 20, 30, 40]
print(enumerate(a))

print(list(enumerate(a)))
    
    
"функция enumerate возвращает кортежи из пары значений, на первом месте пары находится индекс элемента, на втором - значение"
    
    
enumerate  возвращает пару значений, вы можете сразу внутри цикла for завести две переменные - index и value.

a = [ 10, 20, 30, 40]

for index, value in enumerate(a):
  print(index, value)
  
  
"Функция по умолчанию считает индексы с нуля, но можно при помощи параметра start задать начальное значение отсчета. "    

words = ['variation', 'random', 'electronics', 'competence', 'collapse']

for index, value in enumerate(words):
  print(index, value)
  
# 0 variation,1 random,2 electronics,3 competence,4 collapse
  
print('-'*15)


for index, value in enumerate(words, start=10):

  print(index, value) 			# 10 variation,11 random,12 electronics,13 competence,14 collapse,
    
 
 " Можно упростить запись, 'start=' - необязательно. "

=> enumerate(words, 10)"    
    
    
    
    ********************************
Ваша задача на основании создать список кортежей words_with_position, каждый элемент-кортеж должен содержать два значения: само слово и его порядковый номер в списке words

Порядковый номер слов необходимо считать с единицы. Вот к примеру, если бы список words был таким:

words = ['variation', 'random', 'electronics', 'competence', 'collapse']
то на выходите вы должны были получить такой ответ

words_with_position = [('variation', 1),
                       ('random', 2), 
                       ('electronics', 3), 
                       ('competence', 4), 
                       ('collapse', 5)]
В качестве ответа необходимо вывести words_with_position 
    
    
    
    words = ['feel', 'graduate', 'movie', 'fashionable', 'bacon', 
         'drop', 'produce', 'acquisition', 'cheap', 'strength', 
         'master', 'perception', 'noise', 'strange', 'am']

words_with_position = []                 # создаем пустой список для добавления наших кортежей
for i in enumerate(words, start=1):      # циклом получаем каждую пару(кортеж с индексом и словом)
    words_with_position.append(i[::-1])  # разварачивая этот кортеж добавляем его в список
    
print(words_with_position) 

    
    
~~

words_with_position = [ (v, i) for i,  v in enumerate(words, 1) ]
print(words_with_position)

~~

words_with_position = [ pair[::-1] for pair in enumerate(words, start=1)]
print(words_with_position)


~~

words_with_position = []

for index, value in enumerate(words, start=1):
    words_with_position.append((value, index))
    

~~   
   
print([(el[::-1]) for el in enumerate(words, 1)])
print(words_with_position)

~~

a = []

for i, v in enumerate(words, 1):
    a.append((v,i))
print(a)

~~

print(words_with_position := list(map(lambda x: (x[1], x[0]+1), enumerate(words))))



**************************************

Перед вами кортеж english_words

При помощи enumerate обойдите слова этой коллекции и для каждого элемента выведите строку вида

Word № {number} = {word}
Например, для кортежа english_words = ('hi', 'World') ответ был бы таким:

Word № 1 = hi
Word № 2 = World


english_words = ('attack', 'bless', 'look', 'reckless', 'short', 'monster', 'trolley', 'sound',
                 'ambiguity', 'researcher', 'trunk', 'coat', 'quantity', 'question', 'tenant',
                 'miner', 'definite', 'kit', 'spectrum', 'satisfied', 'selection', 'carve',
                 'ask', 'go', 'suggest')


for i, v in enumerate(english_words, 1):
    print(f"Word № {i} = {v}")
    

~~

[print(f'Word № {key} = {value}') for key, value in enumerate(english_words, 1)]

~~

for number, word in enumerate(english_words, 1):
    print(f'Word № {number} = {word}')
    
~~

print(*[f"Word № {a} = {b}" for a, b in enumerate(english_words, 1)], sep="\n")

~~

[print(f'Word № {idx + 1} = {j}')  for idx, j in enumerate(english_words)]

~~

************************************

						Алгоритм Луна
Упрощенная версия алгоритма выглядит так:

Цифры проверяемой последовательности нумеруются справа налево.
Цифры, оказавшиеся на нечётных местах, остаются без изменений.
Цифры, стоящие на чётных местах, умножаются на 2.
Если в результате такого умножения возникает число больше 9, оно уменьшается на значение 9
Все полученные в результате преобразования 16 цифр складываются. Если сумма кратна 10, то исходные данные верны.


Ваша задача проверить является ли введенный номер карты валидным в соответствии с алгоритмом Луны

Входные данные

Входные данные
На вход программе поступает 16 цифр без пробелов и знаков разделителя

Выходные данные
Если номер карты валидный, выведите True, в противном случае - False

~~~

# получаем номер карты создаем из него список состоящий из каждой цифры номера
# проходимся по функции enumerate(numbers)
# если число кратное, то...
 # проверяем если цифра при умножении на 2 больше 9 то отнимаем 9 и заменяем старую цифру в списке на новую
 # иначе заменяем старую цифру на результат от умножения старой цифры на 2
# проверяем если сумма  новых цифр кратна 10, то выводим True, иначе False


numbers = list(map(int, input()))

for index, value in enumerate(numbers):
    if index % 2 == 0:
        if value * 2 > 9:
            numbers[index] = value * 2 - 9
        else:
            numbers[index] = value * 2
if sum(numbers) % 10 == 0:
    print('True')
else:
    print('False')
    
~~

numbers = list(map(int, input()))[::-1]
total_sum = 0

for i, num in enumerate(numbers, 1):
    if not i % 2:
        num = num * 2    
    total_sum += sum(map(int, str(num))) 
    
print(True if not total_sum % 10 else False)

~~

q = list(map(int, input()[::-1]))
for i in range(16):
    if i % 2 == 1:
        q[i] *= 2
        if q[i] > 9:
            q[i] -= 9
print(sum(q) % 10 == 0)


~~

card_number = list(input())
card_number.reverse()
summa = 0

for index, value in enumerate(card_number):
    if int(index)%2 != 0 and int(value)*2<10:
        summa += int(value)*2
    elif int(index) % 2 != 0 and int(value) * 2 > 9:
        summa += ((int(value) * 2)-9)
    else:
        summa+= int(value)
print('True' if summa%10==0 else 'False')

~~

s = 0
for i, d in enumerate(input()[::-1]):
    if not i % 2 or not int(d) % 9:
        s += int(d)
    else:
        s += (int(d) * 2) % 9
print(not s % 10)


~~

print(not sum(int(d) if not i % 2 or not int(d) % 9 else (int(d) * 2) % 9 for i, d in enumerate(input()[::-1])) % 10)


~~

card = list(map(int, input()[::-1]))
total = 0
for ind, num in enumerate(card, start=1):
    if ind % 2 == 0:
        if num * 2 > 9:
            total += num * 2 - 9
        else:
            total += num * 2
    else:
        total += num
print(total % 10 == 0)

~~

sp = [int(i) for i in list(input())]
for i in range(0, 16, 2):
    sp[i] *= 2
    if sp[i] > 9:
        sp[i] -= 9
print(sum(sp) % 10 == 0)






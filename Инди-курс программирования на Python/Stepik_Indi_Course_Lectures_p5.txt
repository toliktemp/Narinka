
=======  Метод подсчета. Сортировка подсчетом в Python ==========

https://stepik.org/lesson/296962/step/1?unit=278690


Метод подсчета используется для нахождения количества элементов в списке, при условии если вам известно в каких пределах будут значения элементов списка. 
Зная сколько раз каждое значение встречается в списке, мы можем получить отсортированный список. 
Поэтому метод подсчета используется при одноименной сортировке

Продемонстрируем метод подсчета на практике. 
Есть список из чисел от 0 до 5, в котором числа могут повторяться. 
Задача – подсчитать сколько раз встретилось каждое число в списке. 
При этом не используя методы списка.

a = [0, 1, 2, 3, 2, 1, 2, 3, 3, 2, 4, 3, 5, 3, 2]


Поскольку у нас в этом списке могут быть только 6 значений из множества (0, 1, 2, 3, 4, 5), то создадим дополнительный список из 6 нулей. 
При этом, индексы этого списка совпадают с возможными значениями нашего первого списка.
 
Поэтому элемент с нулевым индексом нового списка соответствует количеству нулей в первом списке, элемент с первым индексом второго списка отвечает за количество единиц в первом списке и т.д. 

И всё, что осталось – пройтись по первому списку и, например, если нам встречается 0, то увеличить число, стоящее на нулевом индексе второго списка, на 1. 

Наш код в итоге должен выглядеть следующим образом:


a = [0, 1, 2, 3, 2, 1, 2, 3, 3, 2, 4, 3, 5, 3, 2]

count = [0] * 6

for i in a:
    count[i] += 1
    
print(count)


Чтобы было более понятно как это работает, можно запустить программу в режиме отладки. 

В нём видно, какие значения принимает i в определенном моменте и как выполняется count[i] += 1 по ходу работы всего кода.

При этом может быть так, что какого-то из указанных чисел не будет и вовсе. 

Например в списке ниже отсутствует 0

a = [2, 1, 2, 3, 2, 1, 2, 3, 3, 2, 4, 3, 5, 3, 2]

count = [0] * 6

for i in a:
    count[i] += 1
    
print(count)


При запуске такого же кода, только с таким списком мы получим: [0, 2, 6, 5, 1, 1]

Как мы видим, теперь нулевой элемент равен 0, что говорит о том, что нулей в этом списке нет . Так что программа работает так, как и должна.

Результат программы можно использовать для простого вывода, т.е. вывести сколько раз встретилось каждое число. 

Это можно сделать с помощью второго цикла for после первого.

a = [2, 1, 2, 3, 2, 1, 2, 3, 3, 2, 4, 3, 5, 3, 2]

count = [0] * 6

for i in a:
    count[i] += 1
    
for i in range(6):
    print(i, count[i])
    
    
    
Где первое число в строке – число из списка, а второе число – в каком количестве это число встретилось в списке.

Также можно сделать проверку, чтобы убрать вывод тех значений, которые не встретились в нашем списке. 

Для этого добавим условный оператор во второй цикл:

a = [2, 1, 2, 3, 2, 1, 2, 3, 3, 2, 4, 3, 5, 3, 2]

count = [0] * 6

for i in a:
    count[i] += 1
    
for i in range(6):
    if count[i] > 0:
        print(i, count[i])


Также при помощи цикла мы можем раскрыть наш список и отсортировать его по возрастанию:

a = [2, 1, 2, 3, 2, 1, 2, 3, 3, 2, 4, 3, 5, 3, 2]

count = [0] * 6

for i in a:
    count[i] += 1
    
for i in range(6):
    if count[i] > 0:
        print((str(i) + " ") * count[i], end="")
        

Рассмотрим ещё одну задачу, где дана строка и нужно подсчитать сколько раз каждая буква встречалась в строке. 

При этом не имеет разницы большая буква или нет.      
        
        
s = "jhdf HG jgkfYGg jhgkdf 543 *(^$&*#"


Создадим список из такого же числа нулей, как и букв в английском алфавите:

letters = [0] * 26

И здесь на нулевой позиции подсчитываем количество раз, когда встретилась буква a, на первой позиции – буква b и т.д. 

Для того, чтобы убрать разницу между большими и маленькими буквами воспользуемся методом lower(), а так же отсечём условным оператором все символы, которые не являются буквами. 

Код будет иметь вид:       

s = "jhdf HG jgkfYGg jhgkdf 543 *(^$&*#"

letters = [0] * 26

for i in s.lower():
    if i >= "a" and i <= "z":
        print(i)        
        
        
Этот код позволит вывести все те символы из строки, которые нам нужны. 

Нам осталось только установить соответствие: a = 0, b = 1 и т.д.

Для этого нужно воспользоваться функцией ord, которая принимает символ и возвращает его порядковый номер в кодировке ASCII. 

Для проверки в каком диапазоне находятся наши символы мы можем ввести в эту функцию по очереди крайние наши символы:        
    

print(ord("a"))
print(ord("z"))


Получается, что наши символы букв имеют коды от 97 до 122, а индексы списка лежат в пределах от 0 до 25

В итоге, чтобы получить нужные нам значения, нужно отнимать от получившихся значения число 97 (ord("a") = 97, чтобы получить 0 необходимо 97-97, ord("z") = 122, чтобы получить 25 необходимо 122-97).

В итоге наш код будет иметь следующий вид:
        
        
s = "jhdf HG jgkfYGg jhgkdf 543 *(^$&*#"

letters = [0] * 26

for i in s.lower():
    if i >= "a" and i <= "z":
        nomer = ord(i) - 97
        letters[nomer] += 1
        
for i in range(26):
    if letters[i] > 0:
        print(i, letters[i])
        
        
При выводе мы видим не буквы, а номера из-за того, что мы подстроили каждую букву под номер индекса. 

Теперь ввернём буквы, для этого существует схожая с ord() функция – chr(), которая из определенного номера выводит его символ в ASCII, стоит так же не забывать, что мы отнимали 97, так что мы теперь должны прибавить это число. 

В итоге наш код будет следующим:        

s = "jhdf HG jgkfYGg jhgkdf 543 *(^$&*#"

letters = [0] * 26

for i in s.lower():
    if i >= "a" and i <= "z":
        nomer = ord(i) - 97
        letters[nomer] += 1
        
for i in range(26):
    if letters[i] > 0:
        print(chr(i+97), letters[i])
        

Также мы можем отсортировать нашу строку:

s = "jhdf HG jgkfYGg jhgkdf 543 *(^$&*#"

letters = [0] * 26

for i in s.lower():
    if i >= "a" and i <= "z":
        nomer = ord(i) - 97
        letters[nomer] += 1
        
for i in range(26):
    if letters[i] > 0:
        print(chr(i+97) * letters[i], end="")        
        
        
Обратите внимание, что в этой задаче мы использовали смещение (сначала мы в ord() отнимали 97, а потом делали обратную операцию другим смещением - в chr() прибавляли 97).

Смещение может понадобиться и в следующем примере. 

Заполним список случайными числами в пределах от -10 до 10.      
        
        
import random

a = []

for i in range(10):
    a.append(random.randint(-10, 10))
    
print(a)    


В нашем списке присутствуют отрицательные значения, но индексы списка начинаются с нуля.
 
Что в таком случае делать? 

Необходимо изначально посчитать сколько всего элементов может быть на данном промежутке. 

Их у нас 10 положительных, 10 отрицательных и 0 – в итоге 21. 

Создадим список count, состоящий из 21 нуля.

count = [0] * 21


В итоге нулевой индекс отвечает за число -10, первый индекс за -9 … и 20 индекс отвечает за число 10.

Значит нужно значение -10 превратить в индекс 0, -9 в 1 и т.д. 

Здесь мы видим, что необходимо сместить значение на +10. 

Таким образом код должен быть следующим:


import random

a = []
for i in range(10):
    a.append(random.randint(-10, 10))

count = [0] * 21
for i in a:
    count[i+10] += 1
print(a)

for i in range(21):
    if count[i] > 0:
        print(i-10, count[i])


        
Здесь мы получили список из случайных элементов, а после идёт подсчёт сколько раз этот элемент встречался в списке.

Таким образом, метод подсчёта позволяет найти сколько раз определенное значение встречалось в списке. 

Но у этого метода есть свои ограничения:

необходимо знать в каких пределах элементы могут находиться (от этих пределов зависит размер побочного списка) даже если пределы известны, но они будут очень большими, то такой способ будет нецелесообразным, поскольку побочный список будет занимать слишком много памяти.      
        
        
=================================

На вход вашей программе поступает положительное целое число n, 
а ваша задача вывести в порядке возрастания все цифры, которые встречались 
в этом числе, и напротив каждого также необходимо вывести сколько раз данная цифра встречалась в числе n     

a = list(map(int, str(input())))  # вводим строку и сразу преобразуем ее в список.

count = [0]*10                      # создаем список из 10 нулей для подсчета чисел (от 0 до 9)

for i in a:                      			# Проходимся по нашему списку, считая какие цифры есть и сколько их. 
                                 			# т.е.[i] это индекс нашего списка из 10 нулей. 
    count[i] += 1                	# к каждому соответствующему индексу ставим +1 
    
for i in range(10):              	# проходимся по заполненному списку (бывший из нулей)
    if count[i] > 0:             		# выводим только те значения что не являются 0
        
        # печать i-ый индекс(цифра) и количество i-ых цифр в введеном числе
        print(i, count[i]) 
        
        
        

==================================

Сортировка подсчетом

Как видно из названия задачи, вам необходимо отсортировать список, 
состоящий только из чисел в пределах от -100 до 100 включительно, сортировкой подсчетом.

Программа получает на вход число n - количество элементов в списке, затем сами элементы списка

Вам необходимо вывести отсортированный список

P.S. не пользуйтесь встроенной функцией sorted или методом sort    
        
        
n = int(input())

a = map(int, input().split())

count = [0] * 201  					# список count заполняется нулями

for i in a:  									# перебор всех элементов в а
    count[i] += 1  						# к элементу count с индексом i прибавляется 1, 
    											# т.е. подсчет сколько данное число встречается в а

for i in range(-100, 101):  		# перебор в пределах от -100 до 100 включительно
    for _ in range(count[i]):  		# если по индексу i в count есть ненулевое значение, оно будет выведено 
    
        										# например count[i] =0 то ни чего не выведет
        										# например count[i] =2 то цифру i выведет 2 раза 
        print(i, end=' ')          
        
        
        
        
==============    5.6 Вложенные циклы    ================        
        

https://stepik.org/lesson/296963/step/1?unit=278691


"Цикл называется вложенным, если находится внутри другого цикла."

Формат вложенных циклов:

for <переменная> in <объект>:
    for <переменная> in <объект>:
        <действие>
    <действие>
        
        
В данном примере вложенным будет второй цикл, потому что он расположен внутри первого цикла, который будет называться внешним.

Разберём принцип работы вложенных циклов на примере. 

"Стоит сразу сказать, что для внутреннего цикла необходимо использовать другую переменную."

"Принято использовать букву j, однако это может быть и другая переменная."


for i in range(3):
    for j in range(5):
        print("*", end=" ")
    print()
    
    
* * * * * 
* * * * * 
* * * * * 
    
Если посчитать, то удостоверимся, что их 15, поскольку наш внешний цикл выполнился 3 раза и для каждого его обхода мы делали 5 раз внутренний цикл.        
        


Здесь мы видим, как трижды выполнялся вложенный цикл, который должен 5 раз распечатать *.

Также можно вместо звёздочки выводить что угодно, к примеру переменную i. 


for i in range(3):
    for j in range(5):
        print(i, end=" ")
    print()
    
        
0 0 0 0 0 
1 1 1 1 1 
2 2 2 2 2         

***

for i in range(3):
    for j in range(5):
        print(j, end=" ")
    print()
    

0 1 2 3 4 
0 1 2 3 4 
0 1 2 3 4 

***

for i in range(4):
    for j in range(i):
        print(j, end=" ")
    print()
    
    
0 
0 1 
0 1 2


for i in range(10):
    for j in range(i):
        print(j, end=" ")
    print()
    
    
*** 
   
Этот цикл делается от 0 до 9 и выводить мы будем так же от 0 до 9, только не включая 9.

Чтобы наши значения включались давайте начинать цикл с единицы по 10 в первом цикле и с единицы по i+1 во втором цикле.
    
for i in range(1, 10):
    for j in range(1, i+1):
        print(j, end=" ")
    print()      
      
        
***
    
        
Теперь используем обе переменных, но сократим количество чисел:


for i in range(1, 4):
    for j in range(10, 13):
        print(i, j)        
        
        
Получается, что мы берём первое значение переменной i (1) и для него возьмутся все значения переменной j (10, 11, 12), потом берём следующее значение i (2) и для него опять все значения j (10, 11, 12) и т.д. 

Стоит запомнить, что общее количество повторений будет равняться произведению повторений внутреннего и внешнего цикла (например, в прошлом коде внешний цикл повторяется 3 раза, внутренний – так же 3, 3*3 = 9, 
как мы видим, у нас вывело 9 строк. 

Если увеличить количество повторения цикла внутри до 4 раз, то программа выведет уже 3*4 = 12 строчек.). 

Поэтому запомните, что каждое значение внутреннего цикла будет сочетаться с каждым значением внешнего цикла. То же самое будет, если перебирать строки:


for i in "ab":
    for j in "cde":
        print(i, j)
        
        
a c
a d
a e
b c
b d
b e


***


"Вложенные циклы часто используют для переборов всех возможных значений."


from string import printable

for b1 in printable:
    for b2 in printable:
        for b3 in printable:
            print(b1, b2, b3)
            
            
"Ещё один пример: составим таблицу умножения."

for j in range (1, 10):
    for i in range(1, 11):
        print(i, "*" , j, "=", i*j, end=" ")
    print()
    
    
***

for b1 in "tukva":
    for b2 in "tukva":
        for b3 in "tukva":
            for b4 in "tukva":
                for b5 in "tukva":
                    for b6 in "tukva":
                        rez = b1 + b2 + b3 + b4 + b5 + b6
                        if rez[0] in "tkv" and rez[-1] in "tkv":
                            if rez.count("a") + rez.count("u") == 2:
                                print(rez)
                                
                                
                                
 Эта программа выведет все возможные комбинации, подходящие под условия задачи. 
 Только осталось вместо вывода всех этих вариантов добавить счетчик и вывести его:
 
 
 count = 0
for b1 in "tukva":
    for b2 in "tukva":
        for b3 in "tukva":
            for b4 in "tukva":
                for b5 in "tukva":
                    for b6 in "tukva":
                        rez = b1 + b2 + b3 + b4 + b5 + b6
                        if rez[0] in "tkv" and rez[-1] in "tkv":
                            if rez.count("a") + rez.count("u") == 2:
                                count += 1
print(count) # Получим: 1944


***

Разберём ещё один пример,  следующий код, "который будет считать сумму цифр числа:"

"Например, если ввести 123, то получим 6"

x = int(input())

s = 0

while x > 0:

    s += x % 10
    x  //=  10
    
print(s)

*
The code then enters a while loop that will continue as long as x is greater than 0. 

Inside the loop, "the code adds the last digit of x (found using the modulo operator %) to the variable s." 

"It then updates x to remove the last digit (by using integer division // to discard the remainder)."

This process is repeated until all digits of x have been added to s. 
Finally, the code prints the value of s, which is the sum of all digits in x.

In summary, this code calculates the sum of the digits of a given integer.


***

В другом файле у нас есть цикл for, который перебирает значения в большом диапазоне и нам необходимо в таком диапазоне посчитать сумму цифр этих чисел. 

И раз у нас уже есть код для подсчёта суммы цифр числа, то можно его вставить в цикл for


for i in range(1, 100001):
    x = i
    s = 0
    while x > 0:
        s += x % 10
        x //= 10

    print(i, s)
    
    
======================================


Ваша задача найти сумму всех четырехзначных натуральных чисел, сумма цифр которых равна 20.

Примерами таких чисел являются 9065, 8129, 7355 и тд. У каждого из указанных чисел сумма цифр равна 20



sum = 0
for i in range(1000, 10000):
    if sum(map(int, str(i))) == 20:
        sum += i
print(sum)

Ответ: 3489675


===============================

В этой задаче вам предстоит построить лесенку из чисел. 

Программа принимает на вход целое положительное число n (n<=15) - количество уровней, 
ваша задача вывести n уровней, в каждом из которых стоят числа от 1 до значения уровня.


a = int(input())            		# получаем число строк

for i in range(a):          		# цикл до числа строк

    for j in range(i + 1):  		# в первой строке будут 1 число во второй 2 и т.д  
        print(j + 1, end=' ')
        
    print()


~~

n = int(input())

for i in range(1, n + 1):
    print(*range(1, i + 1))

~~

[print(*[j+1 for j in range(i)]) for i in range(1, int(input())+1)]


~~

[print(*range(1, i + 2)) for i in range(int(input()))]

~~

''' Лесенка '''
[print(*range(1, i + 1)) for i in range(1, int(input()) + 1)]

~~

n = int(input())
a = [] 
for i in range(1,n+1):
    a.append(str(i))
    print(*a)
    
~~

n = int(input())
st = str()

for j in range(1,n+1):
    st = st + " " + str(j)
    print(st)


~~

for i in range(1, int(input()) + 1):
    print(*range(1, i + 1))
    
~~

a=int(input())

for i in range(0,a):
	for j in range(1,2+i):
		print(j, end=" ")
		
	print()


~~

[print(*[j for j in range(1,i+1)]) for i in range(1,int(input())+1)]

~~

for i in range(1, int(input()) + 1):
    print(*list(range(1, i + 1))) 
    
~~

a = int(input())
b = ''

for i in range(1, a+1):
    b = b + str(i) + ' '
    print(b)


=============================

Напишите программу для построения горизонтальных столбчатых диаграмм с помощью символа звёздочки. 

s = input().split()

for i in s:                    # цикл по списку чисел
    
    for j in range(int(i)):    # в цикле печатаем нужное кол-во *
        print('*',end='')
        
    print()                    # переход на новую строку


~~

a = input().split()
for i in a:
    print('*' * int(i))
    
    
~~

lst = list(map(int, input().split()))

for i in lst:

    for j in range(i):
        print('*', end='')
        
    print()

~~

a = map(int, input().split())

for i in a:

    print('*' * i)
    
~~

print(*[int(i) * "*" for i in input().split()], sep="\n")

~~

print(*['*' * int(i) for i in input().split()], sep='\n')


~~

lst = list(map(int, input().split()))

for i in lst:
    for j in range(i):
        print('*', end='')
    print()
    
 ~~
 
 for x in [*map(int, input().split())]:
    print('*' * x)
    
~~

n = list(map(int, input().split()))

for i in n:

    for j in range(1, i+1):
        print('*', end='')
        
    print()  
    
    
 ======================================
 
 Постулат Бертрана
 
Постулат Бертрана (теорема Бертрана-Чебышева, теорема Чебышева) гласит, что для любого n > 1 найдется 
простое число p в интервале n < p < 2n. 

Такая гипотеза была выдвинута в 1845 году французским математиком Джозефем Бертраном (проверившим ее до n=3000000) и доказана в 1850 году Пафнутием Чебышевым. Рамануджан в 1920 году нашел более простое доказательство, а Эрдеш в 1932 – еще более простое.

Ваша задача состоит в том, чтобы решить несколько более общую задачу – а именно по числу n найти количество простых чисел p из интервала n < p < 2n.

"Напомним, что число называется простым, если оно делится только само на себя и на единицу."

ам необходимо вывести на экран одно число – количество простых чисел p на интервале  n < p < 2n.



n = int(input())
count_numbers = 0               # счетчик простых целых чисел
dividers = 0                    # счетчик делителей

for p in range(n + 1, 2 * n):                   # цикл перебора чисел p в промежутке n < p < 2 * n

    for k in range(2, int(p ** 0.5) + 1):       # делители от 2 до квадратного корня (целое число) - середина диапазона
        if p % k == 0:                          # если наше число делится без остатка
            dividers += 1                       # увеличить количество разделителей
            break

    if dividers == 0:                           # если количество делителей равно 0
        count_numbers += 1                      # увеличить количество простых чисел
    dividers = 0                                # сброс счетчика делителей

print(count_numbers)                            # вывести количество простых целых чисел



~~

n = int(input())
a=0
for i in range(n+1,n*2):
    for j in range(2, int (i ** 0.5) + 1):
        if i%j==0:
            break
    else:
        a+=1
print(a)
    

Here's a line-by-line breakdown of the code:

n = int(input()): This line prompts the user to input an integer value, and then converts the input string to an integer value using the int() function. The value is then stored in the variable n.

a = 0: This line initializes a variable a to zero. 
This variable will be used to count the number of prime numbers found in the range (n+1, n*2).

for i in range(n+1,n * 2):: This line starts a for loop that iterates through all the values 
in the range (n+1, n*2) using the range() function. 
For each value of i, the loop checks whether it is prime or not.

for j in range(2, int(i**0.5)+1):: This line starts a nested for loop that iterates through all the values 
of j in the range (2, sqrt(i)+1), where sqrt() is a function that calculates the square root of a given number. 
This loop checks whether i is divisible by any number between 2 and sqrt(i) (inclusive).

if i%j==0:: This line checks whether i is divisible by j without any remainder. 
If it is, that means i is not a prime number, so the break statement is executed to exit the nested for loop.

else: a += 1: If the for loop completes without finding any divisors of i, then i must be a prime number, so the else block is executed, and the variable a is incremented by 1.

print(a): Finally, the code prints the value of a, which represents the total number of prime numbers found in the range (n + 1, n * 2).

~~

from sympy import isprime


n = int(input())
print(sum(1 for i in range(n + 1, 2 * n) if isprime(i)))


~~

count = 0
n = int(input())

# t0 = datetime.datetime.now()

start_of_range = n + 1

if n % 2:
    start_of_range += 1
    
for i in range(start_of_range, 2 * n, 2):
    for j in range(3, int(i ** 0.5) + 1, 2):
        if i % j == 0:
            break
    else:
        count += 1
print(count)

# t1 = datetime.datetime.now()
# dt = (t1 - t0).total_seconds()
# print(dt, ' sec')


~~

n = int(input())

count = 0
a = []

for i in range(n + 1, 2 * n + 1):

    for j in range(2, int(i ** 0.5) + 1):
    
        if i % j == 0:
            count += 1
            
    if count == 0:
        a.append(i)
    count = 0
    
print(len(a))


~~

n = int(input())

def p(t):
    if t == 2:
        return True
    if t % 2 == 0 or t <= 1:
        return False
    
    s = int(t ** 0.5) + 1
    
    for d in range(3, s, 2):
        if t % d == 0:
            return False
    return True

i = 0
for j in range(n + 1, 2 * n):
    if p(j):
        i += 1
        
print(i)


~~

n = int(input())
m = []

for i in range(n + 1, n * 2 + 1):
    m.append(i)
    
    for j in range(2, int(i**0.5) + 1):
        if i % j == 0:
            m.pop()
            break
            
print(len(m))


~~

n = int(input())
iter = 0
for i in range(n+1,2*n):
    for j in range(2, int(i ** 0.5) + 1):
        if i % j == 0:
            break
    else:
        iter += 1
print(iter)

~~

n = int(input())
count = 0

for i in range(n + 1, 2 * n):
    for j in range(2, int(i ** (1/2)) + 1):
        if i % j == 0:
            count += 1
            break
            
print(n - count - 1)


~~

from sympy import isprime

n, cnt = int(input()), 0

for i in range(n, n * 2 + 1):
    if isprime(i) and n < i < 2 * n:
        cnt += 1
        
print(cnt)



===================================

Вот мы с вами и добрались до легендарной сортировки пузырьком. 

Сортировка пузырьком в python. Bubble sort =>

https://www.youtube.com/watch?v=WBaL7ANQbzQ



n = int(input())
l = list(map(int, input().split()))
cnt = 0  # счетчик перестановок

for i in range(0, n - 1):
    flag = False  # Истина, если были перестановки.
    # Ложь - массив отсортирован, можно выходить из цикла
    
    for j in range(n - i - 1):
        if l[j] > l[j + 1]:  # если предыдущее число больше следующего, то надо переместить
            l[j], l[j + 1] = l[j + 1], l[j]  # перемешаем значения
            cnt += 1  # плюсуем счетчик
            flag = True
    if not flag:
        break
        
print(*l, '\n' + str(cnt))




def bubble_sort(arr):
    n = len(arr)

    # Traverse through all array elements
    for i in range(n):

        # Last i elements are already in place
        for j in range(0, n-i-1):

            # Traverse the array from 0 to n-i-1
            # Swap if the element found is greater than the next element

            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]


This function takes an array arr as input and modifies it in place by sorting it in ascending order using the bubble sort algorithm. 
The outer loop iterates n times, where n is the length of the array. 
The inner loop traverses the array from index 0 up to n-i-1, comparing adjacent elements and swapping them if necessary. 
At the end of each iteration of the outer loop, the last i elements are guaranteed to be in their final sorted positions.

Here's an example of how to use the function:

arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print("Sorted array:", arr)


~~

n = int(input())

lst = [int(i) for i in input().split()]

counter = 0

for i in range(1, n):
    for j in range(n - i):
        if lst[j] > lst[j + 1]:
            lst[j], lst[j + 1] = lst[j + 1], lst[j]
            counter += 1

print(*lst)
print(counter)


~~

n = int(input())
a = list(map(int, input().split()))
s, x = 1, 0

while s != 0:
    s = 0
    
    for i in range(n-1):
        if a[i+1] < a[i]:
            a[i+1], a[i] = a[i], a[i+1]
            s = s + 1
            x = x + 1
            
            
print(*a)
print(x)


~~

def bubble_sort(x, lst):
    lim, count = x, 0
    for _ in range(x - 1):
        flag = 0
        for i in range(lim - 1):
            if lst[i] > lst[i + 1]:
                lst[i], lst[i + 1] = lst[i + 1], lst[i]
                count += 1
                lim, flag = i + 1, 1
        if not flag:
            break
    return lst, count


n = int(input())
nums = list(map(int, input().split()))
res, swap = bubble_sort(n, nums)
print(*res)
print(swap)

~~

n = int(input())
l = list(map(int, input().split()))
last_change = n - 1
counter = 0

while last_change > 0:

    flag = last_change
    for i in range(last_change):
        if l[i] > l[i + 1]:
            last_change = i  # Запомним позицию последнего обмена этой итерации
            l[i], l[i + 1] = l[i + 1], l[i]
            counter += 1
            
    if flag == last_change:  # Если позиция последнего обмена не изменилась, то отсортирован
        break
        
print(*l)
print(counter)


~~

n, nums, counter = int(input()), list(map(int, input().split())), 0

for i in range(n - 1):
    for j in range(n - i - 1):
        if nums[j] > nums[j + 1]:
            nums[j], nums[j + 1] = nums[j + 1], nums[j]
            counter += 1
            
print(*nums)
print(counter)


=====================================


Система уравнений

Фурик очень любит уроки математики, поэтому, в отличие от Рубика, он их не посещает. Но теперь Фурик хочет получить хорошую оценку по математике. Для этого Лариса Ивановна, учительница математики, дала ему новое задание. Фурик сразу же решил эту задачу, а вы сможете?

Нужно посчитать количество пар целых чисел (a, b) (0 ≤ a, b), которые удовлетворяют системе.


n, m = map(int, input().split())

count = 0

for a in range(n + 1):

    for b in range(m + 1):
    
        if a + b ** 2 == m and a ** 2 + b == n:
            count += 1
            
print(count)


~~

n, m = map(int, input().split())

print(sum(a + b * b == m and a * a + b == n for a in range(m + 1) for b in range(n + 1)))


~~

n, m = map(int, input().split())
count = 0

for i in range(n + 1):
    for j in range(m + 1):
        if i ** 2 + j == n and i + j ** 2 == m:
            count += 1
print(count)


~~

from math import sqrt

n, m = map(int, input().split())
res = 0

for a in range(1, int(sqrt(n)) + 1):
    res += (a + (n - a ** 2) ** 2 == m)
    
print(res)


==================================

		Сортировка вставками
		
Это еще один вид сортировки, который реализуется при помощи вложенных циклов


n = int(input())  # Длина массива чисел
s = list(map(int, input().split()))  				# Массив чисел

for i in range(n):  										# Проходим по массиву n раз
    for j in range(i, 0, -1):
        if s[j] < s[j - 1]:  								# Если число меньше чем предыдущее, 
            s[j], s[j - 1] = s[j - 1], s[j]  				# меняем их местами
        else:  												# если условие не выполняется, выходим из внутреннего цикла, 
        														# т.к.предыдущие числа отсортированы
            break
            
print(*s)


~~

n = int(input())
sp = list(map(int, input().split()))

for i in range(n):
    while i != 0 and sp[i] < sp[i - 1]:
        sp[i], sp[i - 1] = sp[i - 1], sp[i]
        i -= 1
print(*sp)


~~

''' Сортировка вставками '''
n = int(input())
d = list(map(int, input().split()))

for i in range(1, n):
    for j in range(i - 1, -1, -1):
        if d[i] < d[j]:
            continue
        else:
            j += 1
            break
    if d[j] > d[i]:
        d.insert(j, d.pop(i))
        
print(*d)


~~

n = int(input())
lst = [int(i) for i in input().split()]

for i in range(1, n):
    k = i
    while k > 0 and lst[k] < lst[k - 1]:
        lst[k - 1], lst[k] = lst[k], lst[k - 1]
        k -= 1


print(*lst)


~~

_ = int(input())
l = [int(i) for i in input().split()]
n = len(l)

for i in range(1, n):
    for j in range(i, 0, -1):
        if l[j-1] > l[j]:
            l[j-1], l[j] = l[j], l[j-1]
print(*l)


~~

n = int(input())
mas = list(map(int, input().split()))

for i in range(n):
    for j in range(i):
        if mas[i] < mas[j]:
            mas[j],mas[i] = mas[i],mas[j]
            
print(*mas)


~~

n, lst = int(input()), list(map(int, input().split()))

for i in range(1, n):
    for j in range(n-1):
        if lst[i] < lst[j]:
            lst[i], lst[j] = lst[j], lst[i]
            
print(*lst)



===========  5.7 Вложенные списки  ============================

https://stepik.org/lesson/296964/step/1?unit=278692

Вложенный список – это список, элементами которого являются также списки. 

a = [[0, 2, 4, 6], [1, 5, 9, 13], [3, 10, 17, 19]]


a = [[0, 2, 4, 6], [1, 5, 9, 13], [3, 10, 17, 19]]

print(len(a))

print(a[2])
print(a[2][1])



a = [[0, 2, 4, 6], [1, 5, 9, 13], [3, 10, [14, 15, 16], 17, 19]]

print(a[2])
print(a[2][2])
print(a[2][2][1])



b = ["hello", "hi", "world"]
print(b[2])
print(b[2][0])


С виду наш список b не является вложенным, "однако мы должны помнить," 
что у каждого символа строки есть номер, 
поэтому мы можем обратиться как к слову world целиком, так и к его любому символу, 

например, к букве w.

Поэтому стоит запомнить, "что строка внутри списка так же является вложенным элементом."


===== Обход элементов вложенного списка =====

Научимся обходить все элементы данного списка. Здесь, как и в обычных списках, существует 2 варианта обхода:

	* "обход по значению"
	
	* "обход по индексу "



Обход по значению =>


a = [
  [0, 2, 4, 6], 
  [1, 5, 9, 13],
  [3, 10, 17, 19]
]
for i in a:
    for j in i:
        print(j, end=" ")
    print()



нам нужно обойти элементы в порядке слева-направо, сверху-вниз. 
При обращении к каждому элементу перед выводом необходимо использовать две пары квадратных скобок, где первая указывает на строку, а вторая на столбец., т.е. наш 0 лежит под индексом [0][0], следующая за ним 2 – под индексом [0][1], последнее число – 19 находится под индексом [2][3]. 

Значит мы при таком подходе фиксируем номер строки и для неё перебираем каждый номер столбца.


a = [[0, 2, 4, 6], [1, 5, 9, 13], [3, 10, 17, 19]]

for i in range(3):

    for j in range(4):
        print(a[i][j], end=" ")
        
    print()



увеличим все значения на 10 и после цикла выведем список a.


a = [
  [0, 2, 4, 6], 
  [1, 5, 9, 13], 
  [3, 10, 17, 19]
]


for i in range(3):

    for j in range(4):
        a[i][j] += 10
        print(a[i][j], end=" ")
    print()
    
print(a)


"При обходе по индексам мы так же можем идти в другом направлении, например, можно двигаться сверху-вниз, а потом слева-направо, т.е. сначала будет выведено 0 1 3, потом 2 5 10 и т.д."


a = [
  [0, 2, 4, 6],
  [1, 5, 9, 13],
  [3, 10, 17, 19]
]

for j in range(4):
    for i in range(3):
        print(a[i][j], end=" ")
    print()



"Можно так же обходить элементы справа-налево, начиная снизу и двигаясь вверх," 
"т.е. сначала получим 19 17 10 3, потом 13 9 5 1 и т.д. "
"Для это в функции range нужно указать убывающую прогрессию до -1, т.к. -1 не учитывается и доходим только до 0."


a = [
  [0, 2, 4, 6],
  [1, 5, 9, 13],
  [3, 10, 17, 19]
]

for i in range(2, -1, -1):
    for j in range(3, -1, -1):
        print(a[i][j], end=" ")
    print()



Таким образом, мы видим, что элементы матрицы можно обойти в любом порядке. 

"Но самый часто используемый вариант обхода – обход слева-направо двигаясь сверху вниз."


============ Нахождение суммы строк или столбцов матрицы ===================


Допустим, нам нужно посчитать сумму каждой строки и каждого столбца. 

Для нахождения суммы строк лучше добавить новую переменную для вычисления суммы, которая будет обнуляться при переходе к новой строке.


a = [
  [0, 2, 4, 6], 
  [1, 5, 9, 13], 
  [3, 10, 17, 19]
]

for i in range(3):
    sum = 0
    
    for j in range(4):
        sum += a[i][j]
    print(sum)


"Для нахождения суммы по столбцам необходимо поменять два эти цикла местами и больше ничего менять не нужно:"

a = [
  [0, 2, 4, 6], 
  [1, 5, 9, 13], 
  [3, 10, 17, 19]
]

for j in range(4):
    sum = 0
    for i in range(3):
        sum += a[i][j]
    print(sum)



=============== Заполнение вложенного списка ===================


Теперь рассмотрим, как можно заполнить вложенный список. 

Для этого необходимы две переменные, которые будут обозначать количество строк n и столбцов m. 

Если нужно заполнить конкретным значением, допустим 0, то для этого можно воспользоваться циклом, в котором будем n раз добавлять список [0] * m раз. 

И для проверки выведем элементы списка a через новый цикл for.


a = []

n = int(input('Введите количество строк: '))

m = int(input('Введите количество столбцов: '))

for i in range(n):
    a.append([0] * m)
    
for i in a:
    print(i)




Также можно вместо нуля в список внести любое другое значение.

Если же нужно в список вносить значения, вводимые с клавиатуры, то необходимо действовать иначе: 

нужно создать промежуточный список и во вложенном цикле добавлять то, что вводите с клавиатуры,

после завершения внутреннего цикла, этот новый список добавляем в наш изначальный:


a = []
n = int(input('Введите количество строк: '))
m = int(input('Введите количество столбцов: '))

for i in range(n):
    b = []
    
    for i in range(m): 
    
        b.append(int(input('Введите элемент: ')))
    a.append(b)
    
for i in a:
    print(i)



=============== Квадратная матрица ===================


Очень часто вы будете иметь дело именно с квадратными таблицами, т.е. размерностью n на n.

В таких таблицах имеется главная диагональ, которая идёт из элемента [0][0] по пути [1][1], [2][2] 
и так до элемента [n][n]. 

Следовательно, у элементов главной диагонали номер строки совпадает с номером столбца, т.е. [i] = [j]
 
Эта диагональ делит матрицу на 2 треугольника. 

Первый треугольник состоит из элементов, расположенных выше главной диагонали: 
с элементами по индексу [0][1], [0][2], [1][2]. Второй треугольник с элементами по индексу [1][0], [2][0], [2][1].

В этих треугольниках наблюдается одна особенность:

У верхнего треугольника i < j, 

т.е. номер строки меньше номера столбца, а у нижнего треугольника i > j, 

т.е. номер строки больше номера столбца.

Теперь рассмотрим следующий пример: на главной диагонали будут лежать 10, ниже будут 3, а выше – 5.

Для этого сначала заполним матрицу нулями и проверим правильность заполнения:


a = []

n = int(input('Введите размер квадратной матрицы: '))

for i in range(n):
    a.append([0] * n)
    
for i in a:
    print(i)



Теперь чтобы изменить значения в этой таблице необходимо обходить их по индексам:


a = []
n = int(input('Введите размер квадратной матрицы: '))

for i in range(n):
    a.append([0]*n)
    
for i in range(n):
    for j in range(n):
        if i==j:
            a[i][j] = 10
        elif i>j:
            a[i][j] = 3
        else:
            a[i][j] = 5
for i in a:
    print(i)


=========== 5.8 Вложенные списки, Часть 2 ================

			Треугольник Паскаля


На этом занятии рассмотрим реализацию вложенных списков в треугольнике Паскаля.
Треугольник Паскаля представляет собой следующую конструкцию:



Нулевой уровень:           	 1
Первый уровень:           	   1 1
Второй уровень:             1 2 1
Третий уровень:            1 3 3 1
Четвертый уровень:    1 4 6 4 1




n = int(input('Введите размер матрицы: '))
triangle = []

for i in range(n+1):
    triangle.append([1] + [0] * n)

for i in triangle:
    print(i)
    
    
[1, 0, 0, 0, 0]
[1, 0, 0, 0, 0]
[1, 0, 0, 0, 0]
[1, 0, 0, 0, 0]
[1, 0, 0, 0, 0]


Теперь наша задача – обходить элементы слева-направо и сверху-вниз, исключая нулевую строку и нулевой столбец:


for i in range(1, n+1):
    for j in range(1, n+1):
        triangle[i][j] = triangle[i-1][j] + triangle[i-1][j-1]


И давайте отдельным циклом выведем элементы нашего треугольника:


for i in range(0, n+1):
    for j in range(0, n+1):
        print(triangle[i][j], end=" ")
    print()
    
    
n = int(input('Введите размер матрицы: '))
triangle = []

for i in range(n+1):
    triangle.append([1] + [0]*n)

for i in range(1, n+1):
    for j in range(1, n+1):
        triangle[i][j] = triangle[i-1][j] + triangle[i-1][j-1]

for i in range(0, n+1):
    for j in range(0, n+1):
        print(triangle[i][j], end=" ")
    print()
    
    
    
Есть только небольшой минус – в этом цикле мы обходим все элементы, т.е. мы берём и те нули, которые стоят выше нашей главной диагонали. 
То есть, допустим, берём первый ноль из первого уровня с индексом [1][2] и получаем его при помощи складывания нулей, стоящих на позициях [0][2] и [0][1]. 

За счёт таких операций наша программа медленнее работает. Это можно исправить, если во внутреннем цикле, изменяющем значения нашего списка, ограничить не до n+1, а до i+1. 

Таким образом, программа будет доходить только до главной диагонали, а следующие за ней значения будут игнорироваться.  
 
 
 
 n = int(input('Введите размер матрицы: '))
triangle = []

for i in range(n+1):
    triangle.append([1] + [0]*n)

for i in range(1, n+1):
    for j in range(1, i+1):
        triangle[i][j] = triangle[i-1][j] + triangle[i-1][j-1]

for i in range(0, n+1):
    for j in range(0, n+1):
        print(triangle[i][j], end=" ")
    print()



Введём 4 и получим:

1 0 0 0 0 
1 1 0 0 0 
1 2 1 0 0 
1 3 3 1 0 
1 4 6 4 1


И если хотите убедиться, что лишние элементы не берутся, то в выводе тоже можно изменить n на i и получим следующий вывод при вводе 4:


n = int(input('Введите размер матрицы: '))
triangle = []

for i in range(n+1):
    triangle.append([1] + [0]*n)

for i in range(1, n+1):
    for j in range(1, i+1):
        triangle[i][j] = triangle[i-1][j] + triangle[i-1][j-1]

for i in range(0, n+1):
    for j in range(0, i+1):
        print(triangle[i][j], end=" ")
    print()




============= 5.9 Генераторы списков Python | List comprehension =========================


https://stepik.org/lesson/372101/step/1?unit=359655

Генераторы списков =>

https://www.youtube.com/watch?v=_zBTBr6XdZo&t=14s



Генераторы списков представляют собой очень мощный и удобный функционал, позволяющий создать список и сразу наполнить его определенными значениями. 

И главный плюс генератора списка в том, что он умещается всего лишь в одну строчку.

"   [выражение for переменная in последовательность]. "

a = [0 for i in range(7)]
print(a)


a = [i for i in range(10)]
print(a)


a = [i**2 for i in range(10)]
print(a)



При делении на 4 могут быть только 4 варианта: 0, 1, 2, 3.

a = [i%4 for i in range(1, 15)]
print(a)



"   В качестве коллекции можно так же обходить и другие итерабельные объекты: строки, списки и т.д.   "

a = [i for i in "hello"]
print(a)

b = [i*5 for i in "hello"]
print(b)



"  можно найти код символа в таблице ASCII:    "

a = [ord(i) for i in "hello"]
print(a)



"  напишем символы, которые располагаются по порядку  "

a = [ord(i) for i in "abcd"]
print(a)


"  В качестве выражения могут выступать и функции из модулей. Например, randint из модуля random. Добавим в список 10 случайных чисел от -10 до 10.  "


from random import randint

a = [randint(-10, 10) for i in range(10)]
print(a)



Теперь обойдём элементы другого списка при помощи генератора. Возьмём генератор из прошлого примера и создадим ещё один, который будет превращать все отрицательные значения в положительные.


from random import randint

a = [randint(-10, 10) for i in range(10)]
print(a)

b = [abs(elem) for elem in a]
print(b)


"  увеличим все значения списка a на 1  "


from random import randint

a = [randint(-10, 10) for i in range(10)]
print(a)

a = [elem+1 for elem in a]
print(a)



	===== Условный оператор в генераторе списка   =====

[выражение for переменная in последовательность if условие]

"  из списка a в список b нужно перенести все элементы, которые являются чётными:  "

from random import randint

a = [randint(-10, 10) for i in range(10)]
print(a)

b = [elem for elem in a if elem%2==0]
print(b)



"  допустим, чтобы делился на 2 и не был отрицательным:  "


from random import randint

a = [randint(-10, 10) for i in range(10)]
print(a)

b = [elem for elem in a if elem%2==0 and elem >= 0]
print(b)



=====  Считывание данных при помощи генератора списка =======


рассмотрим пример, когда мы вводим в одну переменную несколько чисел через пробел через input(). Полученный результат будет являться строкой, а не числом. 
При этом, нельзя просто написать a = int(input()), поскольку это приведёт к ошибке, однако можно разбить строку на составляющие путём метода split():


a = input()
print(a, type(a)) 					# в а хранится строка

a = a.split()
print(a, type(a)) 					# в а хранится список из строк


a = [int(i) for i in a] 				# в а хранится список из целых чисел
print(a, type(a))


"   # в одну строчку все эти преобразования можно записать вот так   "

b =  [ int(num) for num in input('Введите числа для b: ').split() ]

print(b)



"  Такой ввод также можно осуществить при функции map() и записать это в одну строчку  "



=====  Вложенные циклы в генераторе списка =====

"  В генераторах списка также можно использовать двойные циклы.  "


a = [ (i, j) for i in 'abc' for j in [1, 2, 3] ]
print(a)

Output:
[('a', 1), ('a', 2), ('a', 3), ('b', 1), ('b', 2), ('b', 3), ('c', 1), ('c', 2), ('c', 3)]



Принцип работы как при обходе обычных вложенных циклов. 

Мы берём первую переменную из внешнего цикла, и проходим с ней все переменные внутреннего цикла, после чего берётся вторая переменная внешнего цикла и т.д.

Такие вложенные циклы внутри генератора можно сопровождать какими-либо условиями:

a = [i*j for i in [2, 3, 4, 5] for j in [1, 2, 3] if i*j >= 10]
print(a)



=========== Создание матрицы при помощи генератора списка ==========

Допустим вы хотите создать матрицу (двумерный список) и заполнить его значением по умолчанию. 
При помощи генераторов списков это можно легко сделать.  
Допустим, у нас есть n строк и m столбцов. 
И тогда, чтобы создать такой список, состоящий из нулей нам необходимо:

n = 5
m = 4

a = [[0]*m for i in range(n)]
print(a)

print('-'*20)

# вывод по отдельной строке матрицы

for i in a:
    print(i)



Давайте заменим значение одного из элементов созданной матрицы и проверим не затронет ли это изменение другие элементы.

n = 3
m = 4

a = [[0]*m for i in range(n)]

a[1][2] = 100

for i in a:
    print(i)



И мы видим, что только одно значение меняется во всем вложенном списке. Почему это важно?! 
Потому что списки являются изменяемыми объектами, и при неаккуратной работе с ними могут возникнуть неприятности. 
Допустим вы захотели создать двумерный список при помощи еще одной операции умножения как указано в примере ниже


n = 3
m = 4

a = [[0] * m] * n
print(a)

a[1][2] = 100

for i in a:
    print(i)









































========== Функция range и итерируемые объекты ==========

https://stepik.org/lesson/296959/step/1?unit=278687

С помощью функции range() можно сформировать конечную арифметическую прогрессию.

Рассмотрим в консоли функцию range(). Этой функции необходимо передать один аргумент, например, значение 5. Если вы введете в консоли range(5) , то получите range(0, 5)


"Никакой арифметической прогрессии мы не увидели. Чтобы она появилась, оберните  range() в функцию list(), и тогда вы увидите сгенерированную последовательность в виде списка:"

print(list(range(5)))
print(list(range(6)))
print(list(range(11)))
print(list(range(-5)))
print(list(range(0)))



"Обратите внимание, что все последовательности начинаются с 0 и не включают переданное число. Поэтому, если нужно, чтобы последовательность заканчивалась числом 5, то нужно вызвать range(6) ."


"Если указать 0 или отрицательное значение, то получим пустую последовательность. Это связано с тем, что по умолчанию функция range() формирует возрастающую арифметическую прогрессию, начинающуюся с нуля, с шагом один. А от нуля до отрицательного числа, прибавляя единицу, пройти не получится."



~~~~~~~~~~~~~~ Вызов range c двумя параметрами ~~~~~~~~~~~~~

В функцию range() можно также передавать второй параметр. В таком случае первое число говорит о том, откуда будет начинаться отсчёт, а второе – где он будет заканчиваться (не включительно!). 

Например:

print(list(range(10, 20)))
print(list(range(16, 25)))
print(list(range(-5, 5)))
print('-'*20)
print(list(range(11, 100)))
print('-'*20)
print(list(range(15, 5)))


"Нельзя передать в функцию два параметра, в которых первый будет больше, чем второй. В таком случае мы так же получим пустую последовательность.  Потому что range по умолчанию пытается создать возрастающую арифметическую прогрессию, в которой следующее значение всегда больше предыдущего на 1."


~~~~~~~~~~~~~ Вызов range c тремя параметрами ~~~~~~~~~~~~~~~~~~~


Повлиять на возрастание или убывание последовательности можно при помощи третьего параметра. Он влияет на шаг арифметической последовательности, т.е. на разницу между элементами. 

Например:

print(list(range(1, 100, 10)))
print(list(range(16, 25, 2)))
print(list(range(5, 50, 5)))
print('-'*20)
print(list(range(10, 0, -1)))
print(list(range(5, -5, -1)))
print(list(range(10, -10, -2)))
print('-'*20)
print(list(range(15, 5, 2)))



В первом примере мы берем список от 1 до 100 с шагом 10 (каждое десятое число), т.е. сначала 1, потом 1+10 = 11, 11+10=21 и т.д. до 91.

Обратите внимание, если бы у нас была такая запись:

print(list(range(1, 101, 10)))

то 101 мы бы всё равно не получили, поскольку арифметическая прогрессия формируется в данном случае по 101 не включительно. Поэтому, чтобы получить в этом списке 101, необходимо указать любое значение от 102 до 111.

"При помощи третьего параметра можно указать и убывающую арифметическую прогрессию," 

например:

list(range(10, 0, -1))

"В этом случае мы получим значения от 10 до 1. "


С помощью указания шага можно взять любые удобные для вас числа, "например, все четные числа," которые меньше 100, начиная с нуля:

list(range(0, 100, 2))
Итак, у нас есть три варианта использования range():

С одним параметром. В последовательность войдут все числа от 0 до этого числа, не включая число.

С двумя параметрами. В последовательность войдут все числа с первого (включительно) до второго (не включительно).

С тремя параметрами. В последовательность войдут числа с первого (включительно) до второго (не включительно) с шагом, равным третьему числу.


~~~~~~~~~~~~~~ Операции с  range ~~~~~~~~~~~~~~~~~


Что ещё можно сделать с данной функцией?

1) Можно найти сумму арифметической прогрессии. Например, посчитать сумму чисел от 1 до 100. Для этого можно воспользоваться функцией sum() и передать ей на вход последовательность чисел от 1 до 100:

sum(range(1, 101)) # Получим: 5050
Если есть сомнения в правильности, то можно вызвать ту же функцию, только с последовательностью поменьше, например, найти сумму чисел от 1 до 3:

sum(range(1, 4)) Получим: 6



2) Можно посчитать количество чисел в последовательности при помощи функции len(). К примеру, узнаем, сколько есть чисел от 5 до 15 (не включительно) при шаге в 5:

len(range(5, 15, 5)) # Получим: 2



3) Можно использовать в конструкции множественного присвоения. Например:

a, b, c = range(5,16, 5)
Получим, что a = 5, b = 10, c = 15



4) Результат функции можно сохранить в переменную:

r = range(1, 7)


У этой переменной можно:

	узнать количество элементов:
		len(r) # Получим: 6
		
	обратиться к её элементу по индексу:
		r[1] # Получим: 2
		
Напоминание: индексация начинается с 0, поэтому чтобы получить 1, необходимо указать r[0]. Если использовать r[1], то на выходе получится 2.



~~~~~~~~~~~~~~ Итерируемый объект ~~~~~~~~~~~~~~~~~


Итерируемый объект – объект, предоставляющий возможность поочередного прохода по своим элементам. Т.е. сам объект range() является итерируемым объектом.

Рассмотрим это на примере. Для начала итератор нужно создать при помощи функции iter()

v = iter(range(5))
print(v)


Видим, как на экране распечатался адрес нового созданного объекта range_iterator

Итераторы нужны для обхода элементов, хранящихся внутри итератора. Как это сделать? Как обходить элементы?

"Очень просто, через функцию next(). "


Сам итератор хранит в себе информацию о последовательности пройденных элементов и о том, какой элемент будет обходиться следующим. Т.к. мы не брали еще никакой элемент, то мы получим сначала первый, потом второй и тд


v = iter(range(5))
print(next(v))
print(next(v))
print(next(v))
print(next(v))
print(next(v))


В случае, если после вызова последнего элемента будет ещё одна попытка вызова этой функции, то мы получим ошибку StopIteration, которая говорит о том, что все элементы были пройдены и больше элементов нет.


Таким образом, итерируемые объекты позволяют поочередно пройти по всем своим элементам, и они поддерживают вызов функции next() . При обходе создаётся итератор, запоминающий на каком элементе мы сейчас находимся. После завершения обхода всех элементов последующая попытка вызова функции nextведёт к исключению StopIteration.

"К итерируемым объектам относятся списки"

n = iter([43, True, "hello "])

print(next(n))
print(next(n))
print(next(n))

#Если расскоментировать строку ниже, получите ошибку StopIteration
#print(next(n))



К итерируемым объектам также относится строка.

"  n = iter('hello')  "

print(next(n))  # выводим первый элемент        
print(next(n))  # выводим второй элемент
print(next(n))  # выводим третий элемент
print(next(n))  # выводим четвертый элемент
print(next(n))  # выводим пятый элемент


"Числа – не итерируемые объекты."


~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Какой список сформируется, если выполнить команду list(range(4))?
=> [0, 1, 2, 3]

~~~

Допишите программу так, чтобы она печатала на экран список, содержащий последовательность чисел 0,1,2,3,4,5,6,7,8,9 ?

=> print(x:= list(range(10)))

~~~

Сколько элементов содержит в себе range(123)? 

Или другими словами, какова длина последовательности ниже

elements = range(123)
print(len(elements))				=> 123


~~~

Какой список сформируется, если выполнить команду list(range(5, 10))?

=> [5, 6, 7, 8, 9]


~~~

Какой список сформируется, если выполнить команду list(range(10, 5))?
=> [ ]


~~~

Какие параметры необходимо передать в функцию range, чтобы получилась последовательность чисел от 12 до 34 включительно ?

print(list(range(12, 35 )))

~~~

Сколько элементов содержит в себе range(1, 77)? 

Или другими словами, какова длина последовательности ниже

elements = range(1, 77)
print(len(elements))

~~~


Какой список сформируется, если выполнить команду list(range(15, 35, 5))?
=> [15, 20, 25, 30]

~~~

Теперь давайте добавим шаг. Необходимо сформировать последовательность 25, 33, 41, 49, 57 .... , 169

=> "      print([*range(25, 170, 8)])            print(list(range(25, 169 + 1, 8)))         "

print(list(range(25, 174, 8)))

print(list(range(25,170,33-25)))


def sequence_of_numbers(number1, number2):
    lst = []
    step = 8
    for value in range(number1, number2, step):
        lst.append(value)
    return lst

print(sequence_of_numbers(25, 170))



~~~

Какой список сформируется, если выполнить команду list(range(20, 8, -3))?

print([*range(20, 8, -3)])   => [20, 17, 14, 11]


~~~

Нам осталось поработать с убывающими последовательностями.

Сформируйте последовательность -11, -12, -13, -14 .... , -35


=> "   sequence = [i for i in range(-11, -36, -1)] 	print([*range(-11, -36, -1)])   "


print(list(reversed(range(-35, -10))))

print(list(range(-35, -10))[::-1])


print(sorted(list(range(-35, -10)), reverse=True))


print('[-11', end=', ')
for i in range(-12, -35, -1):
    print(i, end=', ')
print('-35]')

~~~


Еще одну

Сформируйте последовательность 10, 9, 8, 7, ... , 0

print([*range(10, -1, -1)])

~~~

print([*range(11)[::-1]])

~~~

print(list(reversed(range(11))))

~~~~~~~~~~~~~~~~

И последняя последовательность 1000, 950, 900, 850, ... , 500

print([*range(1000, 450, -50)])


print(list(range(1000,499,-50 )))


print(sorted(list(range(500, 1001, 50)), reverse=True))


print(list(range(1000, 451, -50)))


print(list(reversed((range(500,1001, 50 )))))


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Что произойдет, если после кода ниже еще раз вызывать print(next(objs))?

objs = iter([23, 78, True, 'hello', [123, 433]])
print(next(objs))
print(next(objs))
print(next(objs))

=> получим 'hello'


~~~~~~~

Что произойдет, если после кода ниже еще раз вызывать print(next(objs))?

objs = iter([23, 78, True, 'hello'])
print(next(objs))
print(next(objs))
print(next(objs))
print(next(objs))


=> получим  исключение StopIteration


=========== 5.2 Цикл for. Обход элементов функции range ============

https://stepik.org/lesson/296960/step/1?unit=278688


Цикл for позволяет поочередно обойти все элементы итерируемой последовательности или итерируемого объекта. Сегодня рассмотрим использование цикла for с функцией range().


" Формат цикла for:"

for <переменная> in <последовательность>:

    <тело цикла>



for i in range(4):
    print(i)


Цикл for присваивает переменной i первый элемент последовательности из range, который равен 0. Затем мы выводим 0, возвращаемся в начало цикла и присваиваем  переменной i следующее значение. Так будет работать до тех пор, пока цикл не обойдет всю последовательность.

Обычно в качестве переменной цикла for используют букву  i, но можно назвать эту переменную иначе. Вы можете использовать любое имя, которое будет легко запомнить. Если вы изменили имя переменной в for, то её название должно быть изменено везде, где оно встречается в теле цикла:


for number in range(4):
    print(number)
    
    
Также стоит отметить, что внутри цикла значение этой переменной можно менять, как захочется, но это изменение не повлияет на следующее значение переменной. 

Например:


for i in range(4):
    print(i)
    i = "hello"



"Также стоит учитывать, что после завершения цикла переменная i будет принимать последнее значение последовательности range()"

for i in range(4):
    print("inside", i)
print("outside", i)


Как мы видим, последнее значение i, расположенное вне цикла for, равно последнему значению i внутри этого цикла.



=========== " Применение range в цикле for " =============


Существует 2 варианта применения  функции range() в цикле for. 


							" Вариант 1 "
					
"   Обход какой-то заданной последовательности в цикле for при помощи функции range().   "

Мы это реализовывали, когда в цикле выводили i, т.е. проходили последовательность чисел от 0 до 3. Если нужно пройти другую последовательность, например, все трехзначные числа, то необходимо написать следующий код:


for i in range(100, 1000):
    print(i)
    
    Output: В итоге программа выведет числа от 100 до 999 включительно.


Внутри цикла также можно ставить какие-либо условия, например, можно вывести все числа, которые делятся только на 2 и 7:


for i in range(100, 1000):
    if i % 2 == 0 and i % 7 == 0:
        print(i)
        
~~~ В итоге получим все трёхзначные числа, которые делятся как на 2, так и на 7.


Можно также вывести все квадраты чисел от 1 до 10. Выведем и число, и его квадрат:

for i in range(1, 11):
    print(i, i ** 2)
    
    
В итоге, мы получили числа от 1 до 10 (включительно) и их квадраты.



~~~ мы рассматривали, " как найти сумму чисел от 1 до 100 (включительно) при помощи функции sum() и range(). " Сумму чисел также можно найти при помощи цикла for. 

Для этого создадим новую переменную, в которой накапливается сумма, и которая в начале должна равняться нулю. В самом цикле мы будем добавлять к сумме переменную i, сохраняя это в переменной sum. По завершении цикла выведем результат нашего сложения.


sum = 0

for i in range(1, 101):

    sum = sum + i

print(sum)

~~~

Также часто встречаются задачи, в которых " нужно найти факториал какого-либо числа ". 

"Для нахождения факториала нужно умножить между собой все числа от 1 до этого числа включительно. "

Таким образом факториал  "   4! = 1 * 2 * 3 * 4 = 24   "


pr = 1

for i in range(1, 5):

    pr = pr * i

print(pr)


Здесь мы изменили название переменной так, чтобы оно больше подходило. 
Значение переменной мы изменили с 0 на 1, чтобы не нужно было умножать на 0. В функции range() подставили нужные нам значения. Далее мы умножаем переменные < pr > и  < i > между собой.

~~~

Чтобы найти факториал числа n, необходимо добавить переменную, которая принимает вводимое значение, и указать эту переменную + 1 в функции range (+1 необходим, т.к. если просто указать это число, то цикл не сможет его взять). В итоге код будет следующим:

n = int(input('Введите число: '))

pr = 1

for i in range( 1,  n + 1):

    pr = pr * i

print(f'Факториал {n} = {pr}')



							" Вариант 2 "
							

Повторение какого-то действия определенное количество раз. 

Например:

for i in range(3):
    print("hello")



Разберём ещё один пример, в котором нужно вывести 5 случайных чисел от 1 до 100. 

Для этого необходимо импортировать модуль random , а точнее его функцию randint. Функция randint принимает 2 параметра – от какого и по какое число (включительно) нужно выбрать случайное число.


from random import randint

for i in range(5):

    a = randint(1, 100)
    
    print(a, end=" ")


При повторном запуске значения будут уже другими, поскольку числа выбираются случайным образом. Вы также можете изменить диапазон генерации случайных чисел.

" Также можно посчитать их сумму. " Уменьшим общее количество случайных чисел и добавим счётчик. В итоге получится следующий код:

from random import randint

s = 0

for i in range(3):
    a = randint(1, 10)
    s += a
    print(a, end=" ")
print(s)


Здесь мы видим 3 случайных числа и их сумму. Всё это на одной строке, поскольку вместо переноса строки у нас стоит пробел, т.к. мы это указали в параметре end. 

Чтобы вывести их сумму на другую строку, достаточно после завершения цикла поставить пустой print(), параметр end у которого равен переносу строки.


from random import randint

s = 0
for i in range(3):
    a = randint(1, 10)
    s += a
    print(a, end=" ")

print()
print(s)


Можно сделать и так, чтобы пользователь сам вводил нужное ему количество случайных чисел:


from random import randint

s = 0
n = int(input())
for i in range(n):
    a = randint(1, 10)
    s += a
    print(a, end=" ")
print()
print(s)


Во всех этих примерах мы использовали функцию range() только для того, чтобы повторить цикл определенное количество раз, и внутри этих циклов мы нигде не использовали переменную i.

Рассмотрим другие примеры, где можно использовать переменную i. 

Например:


for i in range(1, 11):
    print( "*" * i )
    
    
Это произошло потому, что при умножении строки на число, она (строка) повторяется определенное количество раз. При умножении на 1 мы получили 1 изначальную строку, при умножении на 2 - получили 2 изначальных строки и т.д.



for i in range(1, 11):
    print(2**i)
    
~~~
    
n = int(input())
s = 0

for i in range(n):
    a = int(input())
    s += a
    
    print("current s:" , s)

print("total", s)
print("average =", s/n)    


Теперь при вводе любого числа программа будет работать до тех пор, пока пользователь не введёт указанное количество чисел. 

Например, при вводе 3 мы должны будем ввести 3 числа, и после каждого будет выводиться сумма введенных чисел. В самом конце мы получим общую сумму чисел и среднее арифметическое. 



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Программа принимает на вход натуральное число N. Ваша задача: вывести на экран все числа от 1 до N, каждое число на отдельной строке. 


n = int(input())

for i in range(1, n+1):
    print(i, end='\n')
    
    
~~~
n=int(input())

for i in range(n):
    print( i+1 )

~~~

"" print(*range(1, int(input()) + 1), sep='\n')


~~~

[print(i) for i in range(1, int(input())+1)]

~~~

""   print(*range(1, int(input()) + 1), sep = '\n')
или так

""   [print(i) for i in range(1, int(input()) + 1)]
или так

""   print(*[i for i in range(1, int(input()) + 1)], sep = '\n')

""   print('\n'.join(map(str, [i for i in range(1, int(input()) + 1)])))



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Напишите программу, которая выведет все элементы арифметической прогрессии от 0 до 500 включительно с шагом 5.

Каждый элемент выводится отдельно на своей строке в таком виде


for i in range(0,501, 5):
    print(i)
    
    
~~~

print(*range(0, 501, 5), sep='\n')


~~~

[print(i) for i in range(0,501,5)]

~~~

for i in range(101):
    print(i * 5)
    
~~~

[print(i*5) for i in range(101)]


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Программа принимает на вход натуральное число N. Ваша задача: вывести на экран все числа от N до 1 в сторону уменьшения, каждое число на отдельной строке. 


num  = int(input())

for i in range(num, 0, -1):
    print(i)


~~~

n=int(input())
for i in range(n):
    print(n-i)


~~~

print(*range(int(input()), 0, -1), sep='\n')


[print(i) for i in range(int(input()), 0, -1)]



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Минутка сожаления

«Надо было брать биткоин в 2012!» именно такую фразу ваша программа должна вывести на экран 13 раз


for i in range(13):
    print("Надо было брать биткоин в 2012!")
    

"" print('Надо было брать биткоин в 2012!\n' * 13)


"" [print('Надо было брать биткоин в 2012!') for i in range(13)]



"" print("\n".join(["Надо было брать биткоин в 2012!"] * 13))


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Повторение - мать учения 

Каждый, кто смотрел Симпсонов, помнит, что в начале любой серии Барт писал забавные фразы на доске.


Давайте и мы напишем подобную программу. На вход ей будет поступать фраза и затем количество раз, которое эту фразу нужно повторить.


phrase = input()
num = int(input())

[print(phrase) for i in range(num)]

~~~

""   print(*[input()] * int(input()), sep='\n' )

~~~

""   print((input() + '\n') * int(input()))

~~~

a, b = input(), int(input())
[print(a) for _ in range(b)]


~~~

phrase = input()
count = int(input())
for _ in range(count):
    print(phrase)
    
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		Давайте вспомним задачу FizzBuzz

Напишите программу, которая считывает два натуральных числа a и b (гарантируется, что a<b), после чего для всех чисел от a до b включительно выводит:

“Fizz”, если это число делится на 3;
“Buzz”, если это число делится на 5;
“FizzBuzz”, если выполнены оба предыдущих условия;
само это число в остальных случаях.    


a=int(input())
b=int(input())

for i in range(a, b+1):

    if i % 3 == 0 and i % 5 == 0:   # если делится и на 3 и на 5 без остатка;
        print('FizzBuzz')
    elif i % 5 == 0:                # если делится и на 5 без остатка;
        print('Buzz')
    elif i % 3 == 0:                # если делится и на 3 без остатка;
        print('Fizz')
    else:
        print(i)


~~~

for n in range(int(input()), int(input()) + 1):
    print('Fizz' * (not n % 3) + 'Buzz' * (not n % 5) or n)
    
    
~~~

for i in range(int(input()), int(input()) + 1):
    print((i, "Buzz", "Fizz", "FizzBuzz")[2 * (i % 3 == 0) + (i % 5 == 0)])    
    

~~~

for n in range(int(input()), int(input()) + 1):
    if not n % 3 and not n % 5:
        print('FizzBuzz')
    elif not n % 3:
        print('Fizz')
    elif not n % 5:
        print('Buzz')
    else:
        print(n)
        


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		Квадрат и куб
		
Давайте составим сводную информацию о квадратах и кубах интервала чисел.

На вход программе подается два натуральных числа a и b (гарантируется, что a<b), после чего для каждого целого числа на интервале от a до b включительно необходимо вывести фразу следующего вида:

«Число {число}; его квадрат = {квадрат}; его куб = {куб}»

Кавычки выводить не нужно и пользуйтесь f-строкой.



a = int(input())
b = int(input())

for i in range(a, b + 1):
    print(f'Число {i}; его квадрат = {i ** 2}; его куб = {i ** 3}')


~~~

a = int(input())
b = int(input())

for i in range(a, b+1):
    print(f"Число {i}; его квадрат = {i*i}; его куб = {i*i*i}")
    
~~~

print(*[f'Число {i}; его квадрат = {i**2}; его куб = {i**3}'for i in range(int(input()),int(input())+1)],sep='\n')


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Кратные 3 или 5

Если перечислить все натуральные числа ниже 10, которые кратны 3 или 5, то получим 3, 5, 6 и 9. Сумма этих чисел 23.

Напишите программу, которая принимает натуральное число n и находит сумму всех чисел ниже переданного числа n, которые делятся на 3 или на 5.


num = int(input())

total = 0

for i in range(num):
	if i % 3 == 0 or i % 5 == 0:
		total += i
	
print(total)


~~~

print(sum(i for i in range(int(input())) if not i % 3 or not i % 5))

~~~

a = []

for i in range(int(input())):
    if i % 3 == 0 or i % 5 == 0:
        a.append(i)
        
        
print(sum(a))


~~~

print(sum(i for i in range(1, int(input())) if i % 3 == 0 or i % 5 == 0))

~~~

"" print(sum([i for i in range(int(input())) if not i % 3 or not i % 5]))


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Напишите программу, которая найдет сумму кубов натуральных чисел от 50 до 100 включительно

503 + 513 + 523 + 533 + ... + 1003

total = 0

for i in range(50, 101):
	total = total + i ** 3
	
print(total) 		=> 24001875



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


def factorial(n):
    if n < 0:
        return None
    elif n == 0:
        return 1
    else:
        result = 1
        for i in range(1, n+1):
            result *= i
        return result


~~~

num = int(input())

pr = 1

for i in range(1, num + 1):
    pr *= i
    
print(pr)


~~~

for i in range(n := 1, int(input()) + 1):
    n *= i
print(n)


~~~

n = int(input()) 

for i in range(n-1, 1, -1):
    n *=i
print(n if n>0 else 1)
    
    
"" ~~~ Factorial with Recursion

def factorial(n):
    if n < 0:
        return None
    elif n == 0:
        return 1
    else:
        return n * factorial(n-1)
        
        

result = factorial(5)
print("The factorial of 5 is:", result)


"" ~~~

 from math import factorial
 
print(factorial(int(input())))



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Мишка и игра

Правила её очень просты: сначала определяется значение n — количество раундов игры. В очередном раунде каждый из игроков один раз бросает стандартный игральный кубик, на грани которого нанесены различные числа от 1 до 6. Игрок, выбросивший большее значение, становится победителем в раунде. В случае, если выпавшие значения равны, победа не засчитывается никому.

В самой же игре побеждает участник, выигравший в большем количестве раундов. Если же количества побед, заслуженных игроками, равны, то объявляется ничья.

Мишка ещё совсем маленькая и плохо умеет вести счёт, а потому попросила Вас понаблюдать за ходом игры и сообщить ей результат. Помогите ей!


n = int(input())  		# количество раундов 
M = 0             		# количество выигрышей Мишки
C = 0             		# количество выигрышей Крис

for i in range(n):    #получаем счет раунда
    
    m, c = map(int, input().split())
    if m > c:
        M += 1    
    elif m < c:
        C += 1   

if M > C:         		# определяем победителя
    print('Mishka')
elif M < C:
    print('Chris')
else:
    print('Friendship is magic!^^')


~~~

score = 0

for _ in range(int(input())):
    m, k = map(int, input().split())
    score += (m > k) - (m < k)
    
print(('Friendship is magic!^^', 'Mishka', 'Chris')[(score > 0) - (score < 0)])


~~~

Mishka_wins = 0
Chris_wins = 0

for i in range(int(input())):
    m, c = map(int, input().split())
    if m > c:
        Mishka_wins += 1
    elif m < c:
        Chris_wins += 1

if Mishka_wins > Chris_wins: print("Mishka")

elif Mishka_wins < Chris_wins: print("Chris")

else: print("Friendship is magic!^^")


~~~

n = int(input())
m = []
c = []

for i in range(n):
    a, b = map(int, input().split())
    m.append(a)
    c.append(b)
    
if sum(m) > sum(c):
    print('Mishka')
elif sum(m) < sum(c):
    print('Chris')
else:
    print('Friendship is magic!^^')
    
    
~~~

s = 0

for x in range(int(input())):
    a, b = (int(c) for c in input().split())
    s += 1 if a > b else -1 if a < b else 0
    
print('Mishka' if s > 0 else 'Chris' if s < 0 else 'Friendship is magic!^^')



~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Найдите, в каких строках из введённых и в каком месте упоминается "рок", причем регистр букв не важен.

Вместо явного цикла прохода по строке в цикле используйте подходящий метод строки.


n = int(input())

for i in range(n):     
           
    str = input().lower()                    # строка для поиска подстроки
    idx = str.find('рок') + 1              # индекс 1 символа найденой подстроки
    
    if idx > 0:                                  # если подстрока нашлась
        print(i + 1, idx)                      # то печать (номер строки (цикла), индекс....)


~~~

for i in range(int(input())):
    n = input().lower()
    if 'рок' in n:
        print(i + 1, n.find('рок') + 1)

~~~

for i in range(int(input())):
    s = input().lower()
    if s.find('рок') != -1:
        print(i + 1, s.index('рок') + 1)
        
        
~~~

s, expression = "", "РОК"

for i in range(int(input())):

    a = input().upper()
    if a.find(expression) >= 0:
        s += str(i+1) + ' ' + str(a.index(expression)+1) + '\n'
        
print(s[:-1])


~~~

n = int(input())
l = []

for i in range(1, n+1):
    u = input().lower()
    if 'рок' in u:
        l.append([i, u.find('рок')+1])
        
for i in l:
    print(*i)


~~~

s = [[i, input().lower().find("рок")] for i in range(int(input()))]
[print(i[0]+1, i[1]+1) for i in s if i[1] != -1]


~~~

for i in range(1,int(input())+1):
    if 'рок' in (x:=input().lower()):
        print(i,x.find('рок')+1)


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Предположим, вы переписываете у друга рецепты в блокнотик, но вам не нравится "соль". Переписывайте без этого слова.

Формат ввода
На первой строке вводится натуральное число N — количество пунктов рецепта.
Далее следуют N строк — пункты рецепта.



count = int(input())
result = ""

for _ in range(count):
    s = input()                # получаем строку рецепта
    if 'соль' in s:            # если есть слово  соль то пропускаем эту строку
        continue
    result += s + ', '         # добавляем значения в результат
    
print(result[:-2])             # убираем в конце запятую и пробел


~~~

s = [input() for i in range(int(input()))]
print(*[i for i in s if not 'соль' in i], sep=', ')


" ~~~ "

s = []

for i in range(int(input())):
    a = input()
    if 'соль' not in a:
        s. append(a)
        
print(*s, sep=', ')


~~~

print(*[i for i in [input() for i in range(int(input()))] if "соль" not in i], sep=", ")


~~~

n = int(input())
b = []

for i in range(n):
    a = input().lower()
    if 'соль' in a:
        del(a)
    else:
        b.append(a)
        
print(*b, sep = ', ')


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		Слишком длинные слова
Иногда некоторые слова вроде «civilization» или «internationalization» настолько длинны, что их весьма утомительно писать много раз в каком-либо тексте.

Будем считать слово слишком длинным, если его длина строго больше 10 символов. Все слишком длинные слова можно заменить специальной аббревиатурой.

Эта аббревиатура строится следующим образом: записывается первая и последняя буква слова, а между ними — количество букв между первой и последней буквой (в десятичной системе счисления и без ведущих нулей).

Таким образом, «civilization» запишется как «c10n», а «internationalization» как «i18n».

Вам предлагается автоматизировать процесс замены слов на аббревиатуры. При этом все слишком длинные слова должны быть заменены аббревиатурой, а слова, не являющиеся слишком длинными, должны остаться без изменений.

Входные данные
В первой строке содержится целое число n (1 ≤ n ≤ 100). В каждой из последующих n строк содержится по одному слову. Все слова состоят из малых латинских букв и имеют длину от 1 до 100 символов.

Выходные данные
Выведите n строк. В i строке должен находиться результат замены i-го слова из входных данных.




n = int(input())             				# получаем число строк

for i in range(n):
    a = input()             				 # получаем строку
    
    if len(a) > 10:          				# если строка больше 10  
        b = a[0]             				# получаем 1 букву
        c = a[-1]            				# получаем последнию букву
        d = a[1:-2]          					# получаем слово без первой и последней буквы
        a = b + str(len(d)+1) + c     # складываем результат и длину len(d)  
        
    print(a) 


~~~

for _ in range(int(input())):
    word = input()
    if len(word) > 10:
        word = word[0] + str(len(word) - 2) + word[-1]
    print(word)
    
~~~

wlist = [input() for _ in range(int(input()))]

for i, s in enumerate(wlist):
    wlist[i] = s[0] + str(len(s) - 2) + s[-1] if len(s) > 10 else s
    
print(*wlist, sep='\n')


~~~

n = int(input())

for i in range(n):
    i =input()
    if len(i)<10:
        print(i)
    else:
        print(i[0],len(i)-2,i[-1],sep='')


~~~

n = int(input())

spisok = []

for i in range(n):
    s = input()
    if len(s) > 10:
        newS = s[0] + str(len(s[1:-1])) + s[-1]
        spisok.append(newS)
    else:
        spisok.append(s)
        
print(*spisok, sep="\n")


~~~

lst = [input() for _ in range(int(input()))]

[print(i[0] + str(len(i) - 2) + i[-1] if len(i) > 10 else i) for i in lst]



=========== 5.3 Цикл for. Обход списков и строк ============

https://stepik.org/lesson/296961/step/1?unit=278689


Цикл for широко используется для обхода упорядоченных коллекций list и str, с которыми мы с вами уже познакомились.  На этом занятии мы ознакомимся с тем, как обходить списки и строки при помощи цикла for. Делать мы можем это двумя способами:

Обход элементов коллекции по значению
Обход элементов коллекции по индексу(порядковому номеру)


		"Обход коллекции по значению в цикле for"
Создадим список из нескольких чисел и используем цикл for для их обхода, все очень похоже как мы это делали с range


a = [43, 65, 3, 54, 6]
for i in a:
    print(i)
    
    

a = [43, 65, 3, 54, 6]
count = 0
for i in a:
    print(i)
    count += 1
    print(count, "обход")
    input('press enter to continue')
    
   
   
Если каждый элемент нашего списка необходимо будет увеличить, допустим на 5, то первой мыслью будет просто увеличить нашу переменную на 5 следующим образом:   


    
a = [43, 65, 3, 54, 6]
for i in a:
    i += 5
    print(i, end=" ")
print()
print(a)



нам необходимо обойти все элементы и указать на каком месте стоит каждый из элементов. Код будет следующим:


a = [43, 65, 3, 54, 6]
for i in a:
    print(a.index(i), i)
    
    
"~~~"   Следовательно, когда мы обходим список по значениям, имеем 2 минуса:

не можем изменять элементы этого списка;
не знаем на каких местах стоят элементы.



===				" Обход коллекции по индексу в цикле for " 	===


А теперь рассмотрим другой вариант обхода элементов списка – обход по индексам. 
Мы знаем, что у каждого элемента списка есть свой порядковый номер. 
Первый элемент имеет порядковый номер 0, и дальше по возрастанию. 
"Таким образом, чтобы пройти циклом for по списку, обращаясь к индексам должна быть следующая запись:"


a = [43, 65, 3, 43, 6]

for i in range(5):
    print(i, a[i])



"  Но у этого кода есть другой изъян, который можно увидеть, если добавить ещё одно число в список:  "

a = [43, 65, 3, 43, 6, 43]

for i in range(5):
    print(i, a[i])



Стоит обратить внимание, что в функции  range может быть число меньшее, чем количество элементов списка (в таком случае просто будет обработаны не все числа списка), но в range не может быть число, превышающее число элементов в списке (тогда возникнет ошибка). 



a = [43, 65, 3, 43]

#этот цикл работает
for i in range(3):
   print(i, a[i])
   
print('-'*20)   

#здесь выходим за границы списка
a = [43, 65]

for i in range(3):
   print(i, a[i])
   
   

Поэтому лучше в функции range() указывать число, равное длине списка. Длину списка можно указать в отдельной переменной или можно сразу использовать в функции range(). Следующий код будет работать вне зависимости от того, какое количество элементов в нашем списке:


a = [43, 65, 3, 43]

b = len(a)

for i in range(b):

	print(f'index: { i },   element value : {a[ i ] }')




Давайте всё-таки увеличим каждую переменную в списке на 5:

a = [43, 65, 3, 43]

b = len(a)

for i in range(b):
    a[i] += 5
    
print(a)


"~~~"   В итоге имеем, что при таком варианте обхода у нас есть возможность обращаться как к индексу элемента, так и к его значению, но обращаться к значению необходимо через его индекс. При этом мы можем изменить элементы списка при такой надобности. 


"  Из этого следует, что обход по индексам является более универсальным способом, чем обход по значениям, поэтому он является более предпочтительным. Обход по значениям применяется там, где нужны только значения из списка, это к примеру: просуммировать элементы списка, найти максимальное/минимальное значение. Но если в задаче необходимо узнать номер какого-то элемента или работать с соседними элементами, то необходимо работать с обходом по индексам."


"~~~" Разберём несколько примеров

Необходимо предоставить список, из которого исключены дубли. 

Поскольку для исключения дублей нам не нужны индексы, тогда можно воспользоваться обходом по значениям. 

Нам необходимо создать второй список и при помощи цикла for проверить есть ли каждый элемент списка a в списке b. 

Если элемента нет, тогда элемент добавляется, если подобный элемент есть – переходим к следующему элементу. 


a = [1, 2, 3, 4, 32, 4, 5, 3, 5]
b = []

for i in a:
    if i not in b:
        b.append(i)
        
print(b)



Теперь из списка a получим 2 списка: 

" индексы с четными и нечётными числами. "

Если нужны номера индекса, то обходим по индексам. 
Для этого необходимо в цикле for вставить условный оператор, который будет проверять делится ли число без остатка на 2. Если да, то в список чётных, в противном случае – в список нечетных.


a = [1, 2, 3, 4, 32, 4, 5, 3, 5]

chet = []
nechet = []
n = len(a)

for i in range(n):
    if a[i] % 2 == 0:
        chet.append(i)
    else:
        nechet.append(i)
        
print(chet)
print(nechet)


Теперь мы видим на каких позициях в списке находятся четные и нечетные числа.

Все эти варианты обхода списков работают и со строками. 
Обойдем строку по значениям:

s = "hElLo"

for i in s:
    print(i)


"~~~" Можно устроить проверку является ли буква маленькой или нет:

s = "hElLo2"

for i in s:
    if i >= "a" and i <= "z":
        print(i, "small")
        
    elif i >= "A" and i <= "Z":
        print(i, "big")
        
    else:
        print(i)
        
        
        
"~~~" 	Рассмотрим ещё один пример. 

В английском гласными являются следующие буквы:" a e i o u "

И допустим у нас есть строка со случайным набором букв и нам нужно вывести пары соседних букв, в которых обе буквы являются гласными. 

До этого мы работали лишь с одним элементом, а теперь у нас их 2. 

" Будем работать с соседом справа, это означает, что если у первого элемента индекс [0], то у второго [1], если у первого [1], то у второго [2] и т.д. "


"~" В общем виде это выглядит так: s[i] --> s[i+1]


А если нам нужны индексы, то обходим строку по ним.
Для начала попробуем просто вывести все пары:


vowels = "aeiou"
s = "aeriooikjoaikl"

n = len(s)

for i in range(n):
    print(s[i], s[i+1])


Output:

a e
e r
r i
i o
o o
o i
i k
k j
j o
o a
a i
i k
k l

Traceback (most recent call last):
  File "/tmp/sessions/5edea54fa4f0e080/main.py", line 5, in <module>
    print(s[i], s[i+1])
IndexError: string index out of range




Мы вывели все элементы, но получили в конце ошибку. 
" ~~~  Это связано с тем, что когда мы обращаемся к правому соседу последней буквы мы выходим за границы строки (т.к. при принте последней буквы l мы не можем напечатать элемент дальше, чем l )."

" ~~~ Отсюда делаем следующий вывод, когда мы обращаемся к паре справа, то мы должны обходить до предпоследнего элемента, если обращаемся к паре слева, то мы должны обходить, начиная со второго элемента. "

Так что правильной будет следующая запись:


vowels = "aeiou"
s = "aeriooikjoaikl"
n = len(s)

for i in range(n-1):

    print(s[i], s[i+1])


"~~~"   Осталось только добавить проверку:

vowels = "aeiou"
s = "aeriooikjoaikl"
n = len(s)

for i in range(n-1):

    if s[i] in vowels and s[i+1] in vowels:
    
        print(s[i], s[i+1])



============== Операторы break continue else ==============


Инструкция for, как и while, является конструкцией, позволяющей организовать цикл. 

У for и while разная логика организации цикла, что влияет на количество повторений цикла, но у них есть сходства: они оба поддерживают команды

" break "
 
" continue "
 
" else "


"При помощи оператора break можно осуществить принудительный выход из цикла. Вы сразу покидаете цикл и перемещаетесь к следующей инструкции после цикла"


for letter in 'Python':
   if letter == 'h':
      break
   print(f'Current Letter : {letter}')
   
print('Закончили упражение!')



	~~~				"Оператор else" 		~~~
					

При помощи оператора else создается блок команд в конце цикла for. 
Этот блок команд будет выполнен, если цикл for завершился сам по себе без ошибок и без принуждения оператором break. 

"Если же цикл был закончен принудительно, то блок else будет пропущен "



for letter in 'Python':
   if letter == 'h':
      break
   print(f'Current Letter : {letter}')
else:
  print('Мы сюда не попадем')
  
print('-'*20)

for letter in 'Python':
   if letter == 'W':
      break
      
   print(f'Current Letter : {letter}')
   
else:
  print('А вот здесь мы побываем')
  
print('Закончили упражение!')




	~~~ 			"  Оператор continue  " 			~~~~
	

При помощи оператора continue можно принудительно осуществить переход в начало цикла, при этом команды, расположенные ниже не выполнятся, и цикл будет выполнять следующую итерацию.

for letter in 'AbracadabRa':
   if letter == 'a':
      continue
   print(f'Current Letter : {letter}')
   
print('Закончили упражнение!')



 	~~~ 		"  Оператор pass   "  		~~~

Цикл  for  обязательно должен иметь блок команд, в котором должна находиться как минимум одна инструкция. 

Вы не можете просто создать цикл for и оставить его пустым. 

" Для создания пустого цикла for можете использовать оператор pass "


for i in range(1000):
  pass

for letter in 'AbracadabRa': 
   if letter == 'a':
      pass
   else:
      print(f'Current Letter : {letter}')
      
print('Закончили упражение!')




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Перед вами список numbers, состоящий из 100 целых чисел

Ваша задачи пройтись в цикле по элементам списка и вывести на экран каждый элемент на отдельной строке

numbers = [99, 50, -16, 9, 47, -62, 5, -64, -68, 85, 11, -20, 16, 96, -43, 46, -25, 33, 81, -30, 64, 66, -11, 60, 3, -5, -1,
 -80, 49, -12, -86, -40, -98, -92, -91, -71, 56, -76, -30, -82, 17, -2, -64, 47, 22, -28, 40, 55, 54, -3, -58, -10,
 -35, -15, -2, -60, 70, 50, -77, 83, -49, 42, 27, -58, -79, -2, -100, -42, -18, 38, 95, 9, 98, -89, -46, 96, 64,
 -35, 41, 94, 1, -90, 29, 23, 39, -3, 11, -65, -64, 52, -69, 32, -14, -49, -28, -11, 85, -75, -6, 15]


print(*numbers, sep='\n')

~

for i in numbers:
    print(i)
    
~
    
[print(i) for i in numbers]

~

for i in range(len(numbers)):
    print(numbers[i])

~

print(*(i for i in numbers), sep='\n')

~

n = len(numbers)

for i in range(n):
    print(numbers[i])


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Перед вами список words, состоящий из 100 строк

Ваша задачи пройтись в цикле по элементам списка и вывести на экран только те элементы, длина которых больше 6.

Выводить каждый элемент нужно на отдельной строке в том же порядке, в котором слова расположены в списке words


words = ['require', 'build', 'head', 'land', 'dark', 'seat', 'have', 'five', 'particularly', 'focus', 'moment',
           'visit', 'past', 'turn', 'bad', 'modern', 'once', 'future', 'pay', 'assume', 'himself', 'physical', 'chance',
           'remember', 'better', 'former', 'believe', 'explain', 'reduce', 'whatever', 'theory', 'during', 'enough',
           'wall', 'commercial', 'challenge', 'tell', 'actually', 'include', 'somebody', 'decade', 'by', 'better',
           'would', 'five', 'cost', 'kitchen', 'our', 'affect', 'board', 'practice', 'full', 'instead', 'apply', 'good',
           'past', 'clearly', 'special', 'both', 'analysis', 'peace', 'truth', 'cultural', 'light', 'answer', 'build',
           'each', 'watch', 'buy', 'theory', 'pretty', 'expect', 'account', 'music', 'sell', 'newspaper', 'reach',
           'fish', 'tax', 'employee', 'start', 'most', 'during', 'citizen', 'develop', 'carry', 'only', 'certainly',
           'rock', 'economy', 'risk', 'later', 'one', 'body', 'star', 'they', 'choice', 'appear', 'return', 'sometimes']

for i in words:
    if len(i) > 6:
        print(i)   


~~~

print(*[i for i in words if len(i)>6],sep='\n')


~~~

[print(i) for i in words if len(i)>6]


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Перед вами список numbers, состоящий из 100 целых чисел

Ваша задача пройтись в цикле по элементам списка и увеличить каждый в 2 раза.

В итоге изначальный список numbers  должен измениться

В качестве ответа распечатайте измененный список numbers


numbers = [1, 2, 3, 4, 5]

for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2

print(numbers)

~~~

for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2
 
print(numbers)


~~~

numbers = [i * 2 for i in numbers]
print(numbers)


"~" ~~~

print(numbers:= [i * 2 for i in numbers])


~~~~~~~~~~~~~~~~~~~~~~~~~~~~

			Заполняем список
			
Ваша задача создать список из n строк. Программа сперва будет принимать натуральное число n, а затем n строк в каждой отдельной строке. 
В качестве ответа выведите получившийся список.

n = int(input())     		    # количество строк
new_lst = []                  # новый пустой список 

for i in range(n):
    str = input()                   # получаем следующую строку
    new_lst.append(str)      # добавляем его в список
    
print(new_lst)


~~~

n, k = int(input()), []

for i in range(n):
    k.append(input())    
print(k)


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		Входные данные

На первой строке вводится один символ — строчная буква.
На второй строке вводится предложение.

Выходные данные:

Нужно вывести список слов (словом считается часть предложения, окружённая символами пустого пространства), в которых присутствует введённая буква в любом регистре, в том же порядке, в каком они встречаются в предложении.


letter = input() 									# вводим букву
sentence = input().split() 					# вводим предложение, сразу разбиваем его на слова в списке


for word in sentence: 					# делаем цикл на проверку каждого слова в списке

    if letter in word.lower(): 			# если заданная буква попадается в слове + задаем условие для проверки любого регистра
    
        print(word) 							# печатаем это слово
        
 
 "~~~"       

letter = input()
s = input().split()

for i in s:
    if letter.upper() in i or letter in i:
        print(i)

~~~

letter = input()
print(*[i for i in input().split() if letter in i], sep='\n')


~~~

a = input()
b = map(str, input().split())

for i in b:
    if a in i.lower():
        print(i)

~~~

a = input().lower()

print(*[i for i in input().split() if a in i.lower()], sep='\n')

~~~

a=input()
c=input().split()

for i in c:
    if a in i:
        print(i)

~~~

one_symvol = input()
sentence = list(input().split())

for i in sentence:
    if one_symvol not in i:
        continue
    print(i)
    
    
~~~

l, s = input(), input().split() 

print(*[s[i] for i in range(len(s)) if l in s[i]], sep='\n')    



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Линейный поиск
Линейный поиск, также известный как последовательный поиск, этот метод используется для поиска элемента в списке. Линейный поиск является одним из базовых алгоритмов, с которым вы должны познакомиться, изучая программирования. Суть алгоритма в следующем: вы должны проверять каждый элемент списка последовательно один за другим, пока не найдете интересующий вас элемент или пока не закончится весь список.

Входные данные
Программа получает на вход в одной строке элементы списка - целые числа, разделенные пробелом. Количество элементов произвольное

И на следующей строке вводится одно число r - значение поиска

Выходные данные
Ваша задача реализовать линейный алгоритм поиска введенного значения r. В случае успеха - выведите порядковый номер(индекс) первого найденного элемента в списке при условии, что индексация начинается с единицы. Если данный элемент отсутствует - необходимо вывести строку ErrorValue


lst1 = list(map(int, input().split()))

lst = list(map(int, input().split()))
idx = int(input())


index_ = lst1.index(idx)
print(index_)


except Exception as e:
        print(f'[X] => {type(e).__name__}: {e}')



a = list(map(int, input().split()))
r = int(input())
n = len(a)

for i in range(n):
    if a[i] == r:
        print(i+1) # Print the index (+1 to match the 1-based indexing)
        break
else:
    print('ErrorValue') # This else block belongs to the for loop, not the if statement


~~~~~~~~

lst, x = input().split(), int(input())
for i in range(len(lst)):
    if int(lst[i]) == x:
        print(i + 1)
        break
else:print('ErrorValue')


~~~

a = input().split()
b = input()
for i in range(len(a)):
    if a[i] == b:
        print(i+1)
        break
else:
    print('ErrorValue')
    
    
~~~

numbera = list(map(int, input().split()))
r = int(input())
ind = 'ErrorValue'
for i, v in enumerate(numbera):
    if v == r:
        ind = i+1
        break
        
print(ind)


~~~

s, r = input().split(), input()

flag = 'ErrorValue'
for i in range(len(s)):
    if s[i] == r:
        flag = i + 1
        break
        
print(flag)


~~~

a = input().split()
b = input()
for i in range(len(a)):
    if b ==  a[i]:
        print(i+1)
        break
if b not in a:
    print('ErrorValue')
    
~~~

s = input().split()
r = input()

for i in range(len(s)):
    if r not in s:
        print('ErrorValue')
        break

    if s[i] == r:
        print(i + 1)
        break
        
        
~~~

lst = list(map(int, input().split()))
r = int(input())

for i, j in enumerate(lst):
    if r == j:
        print(i + 1)
        break
else:
    print('ErrorValue')
    

"~~~"

lst = list(map(int, input().split()))
r = int(input())

for i, j in enumerate(lst):
    if r == j:
        print(i + 1)
        break
else:
    print('ErrorValue')
    

~~~

num_list = list(map(int, input().split())); 

num = int(input())

for index, value in enumerate( num_list ):
    if num == value: print( index+1 ); break
else: print('ErrorValue')    

~~~

n = input().split()
r = input()

for i in range(len(n)):
    if r not in n:
        print('ErrorValue')
        break
    elif r in n[i]:
        print(i + 1)
        break


~~~

numbers, count = list(map(int, input().split())), 0
if (n := int(input())) in numbers:
    while numbers[count] != n:
        count += 1
    else:
        print(count+1)
else:
    print('ErrorValue')
    

~~~

lst, s = input().split(), input()

for i, v in enumerate(lst, 1):
    if v == s:
        print(i)
        break
else:
    print('ErrorValue')
    
~~~

s = list(map(int,input().split()));
r = int(input())

for index, n in enumerate(s,1):
    if n == r:
        print(index)
        break
else:
    print('ErrorValue')
    

~~~

numbers = input().split()

n = input()
for i, number in enumerate(numbers, 1):
    if number == n:
        print(i)
        break
else:
    print('ErrorValue')
    
    
    
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

На вход программе поступает список из целых чисел. Ваша задача найти в данном списке наименьшее положительное значение. В случае, если положительных значений нет, выведите строку "Empty"


# Получаем список чисел в одну строку через пробел
nums = list(map(int, input().split()))

# Создаем пустой список для нужных чисел
valid_nums = []

# получаем числа больше 0 и кладем в новый список
for i in nums:
    if i > 0:
        valid_nums.append(i)
        
# Если новый список пустой выводим Empty
if len(valid_nums) == 0:
    print('Empty')
else:
    print(min(valid_nums)) 			# Выводим на экран минимальное число
    
    
 "~~~"
 
 s = list(map(int, input().split()))
m = max(s)
for i in s:
    if i < m and i > 0:
        m = i
if m > 0:
    print(m)
else:
    print('Empty')


"~~~"

l = [int(i) for i in input().split() if int(i) > 0]

print('Empty' if len(l) == 0 else min(l))


~~~

print((sorted([i for i in map(int, input().split()) if i > 0]) + ['Empty'])[0])


"~~~"

numbers = map(int, input().split())

for number in sorted(numbers):
    if number > 0:
        print(number)
        break
else:
    print('Empty')
    
"~~~"

nums =  [ i for i in map(int, input().split()) if i > 0 ]
if nums:
    print(min(nums))
else:
    print('Empty')    
    
"~~~"
 
 print(min([int(i) for i in input().split() if int(i)>0], default='Empty'))
    
    
 "~~~"
 
 nums = list(map(int, input().split()))
 
valid_nums = [i for i in nums if i > 0]

print('Empty' if not valid_nums else min(valid_nums))
    
    
~~~

# Получаем список чисел в одну строку через пробел
nums = list(map(int, input().split()))
# Создаем пустой список для нужных чисел
valid_nums = []
# Отбираем все нужные нам числа в список
for i in nums:
    if i > 0:
        valid_nums.append(i)
# Если в списке нет нужных нам чисел (valid_nums == 0 or False)
# выводим текст 
if not valid_nums:
    print('Empty')
else:
    # Выводим на экран минимальное число
    print(min(valid_nums))
    

"~~~"

my_list = list(map(int, input().split()))

x = []

for i in my_list:
    if i > 0: x.append(i)
    
print(min(x) if x else 'Empty')    
    
    
~~~

lst = [int(x) for x in input().split()]
minimum = 10 ** 12

for el in lst:
    if 0 < el < minimum:
        minimum = el
        
res = 'Empty' if minimum == 10 ** 12 else minimum

print(res)


"~~~"

lst = sorted([i for i in map(int, input().split()) if i > 0])

print(lst[0] if lst else 'Empty')
    
    
"~ ~ ~"

arr = [int(i) for i in input().split() if int(i) > 0]

print(min(arr) if len(arr) > 0 else 'Empty')    
    

~~~

lst = [i for i in map(int,input().split()) if i > 0] 

print(min(lst) if lst else 'Empty')
    

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Напишите программу, которая находит рекордное количество вхождений (не обязательно подряд) символа в строку.

Формат ввода
Вводится одна строка.

Формат вывода
Выводится одно целое число — максимальное количество раз, которое встречается какая-либо буква (без учёта регистра) или иной символ во введённой строке.
    
    
x = list(input().lower())      		# делаем из слова список букв

y = []                         			# пустой список для количества символов

for i in x:                    			# цикл по списку букв в строке
    y.append(x.count(i))       	# считаем количество текущей буквы в списке
    
print(max(y)) 


"~~~"

s = input().lower()
count = 0

for i in range(len(s)):
    if s.count(s[i]) > count:
        count = s.count(s[i])
        
print(count)  


" ~~~ "

word = input().lower()

print(max([word.count(i) for i in word]))


"~~~"

s = input().lower()

print(max(s.count(i) for i in s))

"~~~"

print(max(s.count(c) for s in (input().lower(),) for c in s))


"~~~"

a = input().lower()
s = []

count = 0
for i in range(len(a)):
    if a[i] not in s:
        s.append(a[i])
    else:
        count+=1
        
print(count+1)
    
    
"~~~"

c = []
m = input().lower()

for i in m:
    c.append(m.count(i))
    
print(max(c))    
    
    
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
Делимость на 11

Для делимости числа на 11 необходимо, чтобы разность между суммой цифр, стоящих на четных местах, и суммой цифр, стоящих на нечетных местах, делилась на 11.

Требуется написать программу, которая проверит делимость заданного числа на 11.    
    
    
    
l = list(map(int,input()))        		# преобразуем число в список 

even = 0
odd = 0          

for i in range(len(l)):  
    if (i)%2==0:        
        even += l[i]    					# cчитаем суммы четных
    else:
        odd +=l[i]  						# и нечетных разрядов числа
        
if (odd - even) % 11 == 0: 		# условие по свойству делимости 
    print('YES')
else:    
    print('NO')    
    
    
 " ~~~ "
 
 n = [int(i) for i in input()]
 
print('NO' if (sum(n[1::2]) - sum(n[0::2])) % 11 else 'YES')
    

~~~

num = input()

print(('NO', 'YES')[(sum(int(i) for i in num[0::2]) - sum(int(i) for i in num[1::2])) % 11 == 0])


~~~

a = input()
sch = 0
snch = 0

for i in range(0, len(a), 2):
    sch += int(a[i])
    
for i in range(1, len(a), 2):
    snch += int(a[i])
    
if (sch-snch) % 11 == 0:
    print("YES")
else:
    print("NO")
    
  
 ~~~
 
'''
for a in range()
'''  
 
 print( ('NO', 'YES') [int(input()) % 11 == 0] )

    
~~~

n=list(input())
ch=[]
nech=[]

for i in range(len(n)):
    if i %2 !=0:
        ch.append(int(n[i]))
    else:
        nech.append(int(n[i]))
        
if (sum(ch )- sum(nech)) % 11 == 0:
    print('YES')
else:
    print('NO')
 
~~~

for i in range(2): pass

print('YES' if int(input()) % 11 == 0 else 'NO')
    
  
~~~

ns=input()

evens=map(int,ns[1::2])
odds=map(int,ns[::2])

if (sum(evens)-sum(odds))%11==0:
  print ("YES")
else:
  print ("NO")  
    
~~~

n = [int(i) for i in input()]

a, b = sum(n[::2]), sum(n[1::2])

k = abs(a - b)

print('NO' if k%11 else 'YES')
    
    
~~~

print(('NO', 'YES')[sum(int(c) * (1 - 2 * (i % 2)) for i, c in enumerate(input())) % 11 == 0])
    
    
"~~~"

[print(('NO', 'YES')[(sum(num[::2]) - sum(num[1::2])) % 11 == 0]) for num in [[int(i) for i in input()]]]


~~~

n = input()

a = sum(int(i) for i in n[::2]) - sum(int(i) for i in n[1::2])

print('NO'*(a%11!=0) or 'YES')

~~~

print(*['YES' if (sum(map(int, s[::2])) - sum(map(int, s[1::2]))) % 11 == 0 else 'NO' for s in [input()]])

~~~

num = input()
even = 0
odd = 0

for i in num[0::2]:
    odd += int(i)
for i in num[1::2]:
    even += int(i)
    
print('YES') if (even - odd) % 11 == 0 else print('NO')  


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

На вход программе подается строка, состоящая из различных символов: буквы, цифры, знаки препинания и т.д.

Ваша задача определить сколько символов в данной строке являются цифрами и также найти сумму всех этих цифр. Например, в строке "Комната 1408" содержится 4 цифры и их сумма равна 13.

В качестве ответа необходимо через пробел вывести 2 числа - количество цифр в введенной строке и их сумму


s = input()

sum = 0                			# сумма цифр
cnt = 0                				# кол-во цифр

for i in (s):
    if ("0" <= i <= "9"): 
        sum += int(i)  			#Считаем сумму 
        cnt += 1       			#Считаем кол-во
    
print(cnt, sum)


"~~~"

a = [int(i) for i in input() if i.isdigit()]

print(len(a), sum(a))    
    
~~~

s, n = list(input()), []
for i in s:
    if i.isdigit():
         n.append(int(i)) 
print(len(n), sum(n))

~~~

[print(len(s), sum(s)) for s in [[int(i) for i in input() if i.isdigit()]]]


~~~

s = input()
c, summa = 0, 0

for x in s:
    if x.isdigit():
        c += 1
        summa += int(x)

print(c, summa)
    
    
" ~ ~ ~ "

s = 0
count = 0

n = input()

for i in n:
    if i in '0987654321':
        count += 1
        s += int(i)
        
print(count, s)    
    
    
~~~

a = input()
ch = list(range(10))
kol = 0
s = 0

for i in ch:
    u = a.count(str(i))
    kol += u
    s += i * u
    
print(kol, s)
    
    
 "~ ~ ~"

# С посощью генератора списка

digit_list = [int(char) for char in input() if char.isdigit()]
print(len(digit_list), sum(digit_list))



# С помощью регулярный выражений

# import re

# digit_list = re.findall(r'\d', input())
# print(len(digit_list), sum([int(i) for i in digit_list]))    
    
    
~~~

s = input()
count = 0
summa = 0

for i in s:
    if i.isdigit() == True:
        count += 1
        summa += int(i)
        
print(count, summa)


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Правильная скобочная последовательность

Одна из стандартных задач на программирование. Подумайте над способом ее решения, если не приходит ничего в голову, загляните в подсказку)

Итак, у нас есть последовательность скобочных символов, состоящая только из символов ( и )

Ваша задача определить является ли введенная скобочная последовательность правильной.

Правильная скобочная последовательность (ПСП) называется строка, состоящая только символов "скобок", где каждой закрывающей скобке найдётся соответствующая открывающая. При этом учитывайте, что:

Пустая последовательность является правильной.
Если A – правильная скобочная последовательность, то (A) – правильные скобочные последовательности.
Если A и B – правильные скобочные последовательности, то AB – правильная скобочная последовательность.
Если введенная строка является ПСП, выведите YES, в противном случае - NO.
    
    
   
~~~

a = input()
c = 0

for i in a:
    if i == '(':
        c += 1
    elif i == ')':
        c -= 1
if c == 0:
    print('YES')
else:
    print('NO')


~~~

s = input()
while '()' in s:
    s = s.replace('()', '')
if len(s) == 0:
    print('YES')
else:
    print('NO')    

~~~

s = input()
while '()' in s:
    s = s.replace('()', '')
print('YES' if len(s) == 0 else 'NO')

~~~

s = input()
while '()' in s:
    s = s.replace('()', '')
print('NO' if s else 'YES')


~~~

total = 0
for i in input():
    if i == '(':
        total += 1
    else:
        total -= 1
    if total < 0:
        print('NO')
        break
else: 
    print('NO' if total != 0 else 'YES')
    
  
  ~~~
  
  stack = ['-']
for c in input():
    if c == '(':
        stack.append(c)
    else:
        if stack[-1] + c == '()':
            stack.pop()
        else:
            print('NO')
            break
else:
    print('YES' if stack == ['-'] else 'NO')
    
 
 ~~~
 
 a = input()
print('YES' if a.count('(') == a.count(')') else 'NO')

~~~

a = input()
l = 0
r = 0

for i in range(len(a)):
    if a[i] == '(':
        l += 1
    if a[i] == ')':
        r += 1
        
if l == r:
    print('YES')
else:
    print('NO')
    
~~~

s = input()

while '()' in s:
    s = s.replace('()', '')
    
print('YES' if len(s) == 0 else 'NO')    


~~~

n=input()

for x in n:
    if '()' in n:
        n = n.replace('()','')
if len(n)==0:
    print('YES')
else:
    print('NO')
    

~~~

t = input()
s = [] 

for c in t:
    if not s:
        s.append(c)
    else:
        if c == ')' and s[-1] == '(':
            s.pop()
        else:
            s.append(c)
            
print("NO" if s else "YES")


~~~

s, p = input(), 0

while((l := len(s))-p):p=l;
s = s.replace('()','')

print(['NO','YES'][l==0])
 
 
~~~

s = input()

for i in range(len(s)//2):
    s = s.replace('()', '')
    
print('YES' if not s else 'NO')
 

~~~

# Данный код проверяет, является ли введенная пользователем скобочная последовательность правильной, то есть каждая открывающая скобка имеет соответствующую закрывающую скобку и каждая закрывающая скобка имеет соответствующую открывающую скобку.
# 
# Для проверки, используется стек - это список, который позволяет добавлять и удалять элементы только с одного конца списка. В данном случае, мы будем добавлять открывающие скобки в стек и удалять их, когда встречаем соответствующую закрывающую скобку.
# 
# Давайте разберем подробно код:

stack = []  # Создаем пустой стек

# Цикл проходит по каждому символу в строке, которую вводит пользователь
for char in input():
    if char == '(':  # Если символ - открывающая скобка, добавляем ее в стек
        stack.append(char)
    else:  # Если символ - закрывающая скобка
        if not stack:  # Проверяем, не пуст ли стек
            print('NO')  # Если пуст, значит закрывающей скобке не соответствует открывающая, выводим 'NO'
            break  # Выходим из цикла
        current_char = stack.pop()  # Извлекаем последнюю добавленную открывающую скобку из стека
        if current_char == '(':  # Проверяем, соответствует ли извлеченная скобка символу '('
            if char != ')':  # Если не соответствует, значит закрывающей скобке не соответствует открывающая, выводим 'NO'
                print('NO')
                break  # Выходим из цикла

# Если стек пустой после прохождения цикла, значит все скобки правильно расставлены, выводим 'YES', иначе - 'NO'
else:
    print(['YES','NO'][bool(stack)])


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Правильная скобочная последовательность 2
Наша программа принимает на вход последовательность скобочных символов. Ваша задача определить является ли введенная скобочная последовательность правильной.

Правильная скобочная последовательность (ПСП) называется строка, состоящая только из символов "скобки", где каждой закрывающей скобке найдётся соответствующая открывающая (причём того же типа). При этом учитывайте, что:

Пустая последовательность является правильной.
Если A – правильная скобочная последовательность, то (A), [A] и {A} – правильные скобочные последовательности.
Если A и B – правильные скобочные последовательности, то AB – правильная скобочная последовательность.
Если введенная строка является ПСП, выведите YES, в противном случае - NO.


pairs = {'()', '[]', '{}'}     					# список открывающихся и закрывающихся скобок

str = input().replace(' ', '') 			# получаем список и чистим его от пробелов


# полученную строку делим пополам т.к при нахождении удаляется сразу 2 символа
for _ in range(len(str) // 2):   			
    for i in pairs:            				# в цикле бежим по заготовленному списку скобок
        str = str.replace(i, '') 		# если нашли пару удаляем ее из строки
        
if len(str)==0:
    print('YES')
else:
    print('NO')    
    
    
    
    
pattern = input()

for i in range(len(pattern) // 2):
    pattern = pattern.replace('{}', '')
    pattern = pattern.replace('()', '')
    pattern = pattern.replace('[]', '')
print('YES' if len(pattern) == 0 else 'NO')  


~~~

row = input()
kv = "[]"
fg = "{}"
gl = "()"
for i in range(len(row)):
    row = "".join(row.split(kv))
    row = "".join(row.split(fg))
    row = "".join(row.split(gl))
if len(row) == 0:
    print("YES")
else:
    print("NO")


~~~

a = input()
b = [1]
for i in range(len(a)):
    if (b[-1] == '(' and a[i] == ')') or (b[-1] == '[' and a[i] == ']') or (b[-1] == '{' and a[i] == '}'):
        b.pop()
    else:
        b.append(a[i])
print('YES' if b == [1] else 'NO')

~~~

s, match, stack = input(), {'[]', '{}', '()'}, ['-']
if len(s) % 2 != 0:
    print('NO')
else:    
    for c in s:
        if c in '[({':
            stack.append(c)
        elif (stack.pop() + c) not in match:
            print('NO')
            break
    else:
        print(('NO', 'YES')[stack[-1] == '-'])
        
        
~~~

alfa = input()
for i in range(len(alfa) // 2 + 1):
    alfa = alfa.replace('{}', '')
    alfa = alfa.replace('[]', '')
    alfa = alfa.replace('()', '')

print('YES' if len(alfa)==0 else 'NO')


~~~

a, b, c = '[]', '{}', '()'
s = input()
for i in range(len(s)//2):
    s = s.replace(a, '')
    s = s.replace(b, '')
    s = s.replace(c, '')
print(('NO', 'YES')[len(s) == 0])    


~~~

s=input()
for i in s:
    s = s.replace('[]', '').replace('()', '').replace('{}', '')
print("YES" if len(s)==0 else "NO")

~~~

a = input()
if not all([a.count('[') == a.count(']'), a.count('(') == a.count(')'), a.count('{') == a.count('}')]):
    print('NO')
elif any([_ for _ in ('[)', '[}', '(]', '(}', '{]', '{)') if _ in a]):
    print('NO')
else:
    print('YES')


~~~

lst = input()

while '()' in lst or '[]' in lst or '{}' in lst:
    lst = lst.replace('()','')
    lst = lst.replace('[]','')
    lst = lst.replace('{}','')
print(('YES', 'NO')[bool(lst)])
    
    
    ~~~
    
 prs = {')': '(', ']': '[', '}': '{'}
 
tmp = []
[tmp.pop() if tmp and prs.get(x) == tmp[-1] else tmp.append(x) for x in input()]

print(["NO", "YES"][not tmp])
    
    
~~~

n = input()
while True:
    if '()' in n:
        n = n.replace('()', '')
    elif '[]' in n:
        n = n.replace('[]', '')
    elif '{}' in n:
        n = n.replace('{}', '')
    else:
        if len(n) == 0:
            print('YES')
            break
        else:
            print('NO')   
            break
            
~~~

s, stek = input(), ''
for _ in s:
    if _ in '({[':
        stek += _
    elif stek > '' and  stek[-1] + _ in ['()', '{}', '[]']:
        stek = stek[:-1]
    else:
        stek += _
        break
print(['NO', 'YES'][stek == ''])
            
                
  